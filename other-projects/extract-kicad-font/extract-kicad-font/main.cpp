//
//  main.cpp
//  extract-kicad-font
//
//  Created by Pierre Molinaro on 01/09/2018.
//  Copyright © 2018 Pierre Molinaro. All rights reserved.
//
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#include <iostream>
using namespace std ;

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

static const char separator [] =
"//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n" ;

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#include "newstroke_font.h"

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

typedef struct {
  int x ;
  int y ;
} VECTOR2D ;

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// From kicad source stroke_font.cpp
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

static void loadNewStrokeFont (FILE * f, const char * const aNewStrokeFont [], int aNewStrokeFontSize) {
  for (int j = 0 ; j < aNewStrokeFontSize ; j++) {
    if (j <= 94) {
      fprintf (f, "//--- Character %C\n", wchar_t (j + ' ')) ;
      fprintf (f, "  segments = [KicadCharSegment] ()\n") ;
    }
    const wchar_t s = j + ' ' ;
    printf ("Character #%d: %C\n", j, s) ;
    int glyphStartX = 0 ;
    int glyphEndX = 0 ;
    bool penDown = false ;
    VECTOR2D point = {0, 0} ;
    int i = 0 ;

    while (aNewStrokeFont [j] [i]) {
      char coordinate[2] = { 0, } ;

      for (int k = 0 ; k < 2 ; k++) {
        coordinate [k] = aNewStrokeFont [j] [i + k] ;
      }

      if ( i < 2 ) { // The first two values contain the width of the char
        glyphStartX = coordinate [0] - 'R' ;
        glyphEndX   = coordinate [1] - 'R' ;
        cout << "  Start " << glyphStartX << ", end " << glyphEndX << endl ;
      }else if ((coordinate[0] == ' ') && (coordinate[1] == 'R')) {
        penDown = false ;
      }else{
        VECTOR2D newPoint = {0, 0} ;
        // In stroke font, coordinates values are coded as <value> + 'R',
        // <value> is an ASCII char.
        // therefore every coordinate description of the Hershey format has an offset,
        // it has to be subtracted
        // Note:
        //  * the stroke coordinates are stored in reduced form (-1.0 to +1.0),
        //    and the actual size is stroke coordinate * glyph size
        //  * a few shapes have a height slightly bigger than 1.0 ( like '{' '[' )
        newPoint.x = coordinate[0] - 'R' - glyphStartX ;
        #define FONT_OFFSET -10
        // FONT_OFFSET is here for historical reasons, due to the way the stroke font
        // was built. It allows shapes coordinates like W M ... to be >= 0
        // Only shapes like j y have coordinates < 0
        newPoint.y = coordinate[1] - 'R' + FONT_OFFSET ;
        // cout << "  (" << newPoint.x << ", " << newPoint.y << ")" << endl ;
        if (penDown) {
          cout << "  line (" << point.x << ", " << point.y << ") --> (" << newPoint.x << ", " << newPoint.y << ")" << endl ;
          if (j <= 94) {
            fprintf (f, "  segments.append (KicadCharSegment (x1: %d, y1:%d, x2:%d, y2: %d))\n", point.x, -point.y, newPoint.x, -newPoint.y) ;
          }
        }else{
          penDown = true ;
        }
        point = newPoint ;
      }

      i += 2 ;
    }
    if (j <= 94) {
      fprintf (f, "  dict [UnicodeScalar (%u)] = KicadChar (advancement: %d, segments: segments)\n", j + ' ', glyphEndX - glyphStartX) ;
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

int main(int argc, const char * argv[]) {
  const char * fileName = "kicad-font.swift" ;
  FILE * f = fopen (fileName, "wt") ;
  fprintf (f, separator) ;
  fprintf (f, "//  This file has been generated by extract-kicad-font tool\n") ;
  fprintf (f, separator) ;
  fprintf (f, "\n") ;
  fprintf (f, "import Foundation\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "\n") ;
  fprintf (f, "class KicadCharSegment {\n") ;
  fprintf (f, "  let x1 : Int\n") ;
  fprintf (f, "  let y1 : Int\n") ;
  fprintf (f, "  let x2 : Int\n") ;
  fprintf (f, "  let y2 : Int\n\n") ;
  fprintf (f, "  init (x1 inX1 : Int, y1 inY1 : Int, x2 inX2 : Int, y2 inY2 : Int) {\n") ;
  fprintf (f, "    x1 = inX1\n") ;
  fprintf (f, "    y1 = inY1\n") ;
  fprintf (f, "    x2 = inX2\n") ;
  fprintf (f, "    y2 = inY2\n") ;
  fprintf (f, "  }\n\n") ;
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "\n") ;
  fprintf (f, "class KicadChar {\n") ;
  fprintf (f, "  let advancement : Int\n\n") ;
  fprintf (f, "  let segments : [KicadCharSegment]\n\n") ;
  fprintf (f, "  init (advancement inAdvancement : Int, segments inSegments : [KicadCharSegment]) {\n") ;
  fprintf (f, "    advancement = inAdvancement\n") ;
  fprintf (f, "    segments = inSegments\n") ;
  fprintf (f, "  }\n\n") ;
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "\n") ;
  fprintf (f, "func kicadFont () -> [UnicodeScalar : KicadChar] {\n") ;
  fprintf (f, "  var dict = [UnicodeScalar : KicadChar] ()\n") ;
  fprintf (f, "  var segments : [KicadCharSegment]\n") ;

  loadNewStrokeFont (f, newstroke_font, newstroke_font_bufsize) ;
  fprintf (f, "//--- Return\n") ;
  fprintf (f, "  return dict\n") ;
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fclose (f) ;
  return 0 ;
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
