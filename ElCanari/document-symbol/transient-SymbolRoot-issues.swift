//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS REGENERATED BY EASY BINDINGS, ONLY MODIFY IT WITHIN USER ZONES
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func transient_SymbolRoot_issues (
       _ self_symbolObjects_issues : [SymbolObject_issues],
       _ self_symbolPins_name : [SymbolPin_name],
       _ self_symbolPins_nameRect : [SymbolPin_nameRect]
) -> CanariIssueArray {
//--- START OF USER ZONE 2
    //--- Inventory of all non empty names, with thier occurrence count
      var dict = [String : Int] ()
      for pin in self_symbolPins_name {
        let name = pin.name
        if name != "" {
          if let n = dict [name] {
            dict [name] = n + 1
          }else{
            dict [name] = 1
          }
        }
      }
    //--- Detect duplicated pin names
      var issues = [CanariIssue] ()
      var idx = 0
      while idx < self_symbolPins_name.count {
        let name = self_symbolPins_name [idx].name
        if let n = dict [name], n > 1, let rect = self_symbolPins_nameRect [idx].nameRect {
          issues.appendSymbolDuplicatedPinNameIssueAt (rect: rect)
        }
        idx += 1
      }
      if self_symbolPins_name.count == 0 {
        issues.appendSymbolNoPinNameIssue ()
      }
      for optionalIssueArray in self_symbolObjects_issues {
        if let issueArray = optionalIssueArray.issues {
          issues += issueArray
        }
      }
    //-------------------- Sort issues
      issues.sort (by: CanariIssue.displaySortingCompare)
    //---
      return issues
//--- END OF USER ZONE 2
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
