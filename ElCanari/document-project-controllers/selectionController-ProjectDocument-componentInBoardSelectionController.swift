//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Derived selection controller ProjectDocument componentInBoardSelectionController
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class SelectionController_ProjectDocument_componentInBoardSelectionController : EBObject {

  //····················································································································
  //   Selection observable property: mX
  //····················································································································

  let mX_property = EBPropertyProxy_Int ()

  var mX_property_selection : EBSelection <Int> {
    return self.mX_property.prop
  }

  //····················································································································
  //   Selection observable property: mY
  //····················································································································

  let mY_property = EBPropertyProxy_Int ()

  var mY_property_selection : EBSelection <Int> {
    return self.mY_property.prop
  }

  //····················································································································
  //   Selection observable property: mRotation
  //····················································································································

  let mRotation_property = EBPropertyProxy_Int ()

  var mRotation_property_selection : EBSelection <Int> {
    return self.mRotation_property.prop
  }

  //····················································································································
  //   Selection observable property: mSide
  //····················································································································

  let mSide_property = EBPropertyProxy_ComponentSide ()

  var mSide_property_selection : EBSelection <ComponentSide> {
    return self.mSide_property.prop
  }

  //····················································································································
  //   Selection observable property: mNameIsVisibleInBoard
  //····················································································································

  let mNameIsVisibleInBoard_property = EBPropertyProxy_Bool ()

  var mNameIsVisibleInBoard_property_selection : EBSelection <Bool> {
    return self.mNameIsVisibleInBoard_property.prop
  }

  //····················································································································
  //   Selection observable property: mXName
  //····················································································································

  let mXName_property = EBPropertyProxy_Int ()

  var mXName_property_selection : EBSelection <Int> {
    return self.mXName_property.prop
  }

  //····················································································································
  //   Selection observable property: mYName
  //····················································································································

  let mYName_property = EBPropertyProxy_Int ()

  var mYName_property_selection : EBSelection <Int> {
    return self.mYName_property.prop
  }

  //····················································································································
  //   Selection observable property: mNameFontSize
  //····················································································································

  let mNameFontSize_property = EBPropertyProxy_Double ()

  var mNameFontSize_property_selection : EBSelection <Double> {
    return self.mNameFontSize_property.prop
  }

  //····················································································································
  //   Selection observable property: mNameRotation
  //····················································································································

  let mNameRotation_property = EBPropertyProxy_Int ()

  var mNameRotation_property_selection : EBSelection <Int> {
    return self.mNameRotation_property.prop
  }

  //····················································································································
  //   Selection observable property: mValueIsVisibleInBoard
  //····················································································································

  let mValueIsVisibleInBoard_property = EBPropertyProxy_Bool ()

  var mValueIsVisibleInBoard_property_selection : EBSelection <Bool> {
    return self.mValueIsVisibleInBoard_property.prop
  }

  //····················································································································
  //   Selection observable property: mXValue
  //····················································································································

  let mXValue_property = EBPropertyProxy_Int ()

  var mXValue_property_selection : EBSelection <Int> {
    return self.mXValue_property.prop
  }

  //····················································································································
  //   Selection observable property: mYValue
  //····················································································································

  let mYValue_property = EBPropertyProxy_Int ()

  var mYValue_property_selection : EBSelection <Int> {
    return self.mYValue_property.prop
  }

  //····················································································································
  //   Selection observable property: mValueFontSize
  //····················································································································

  let mValueFontSize_property = EBPropertyProxy_Double ()

  var mValueFontSize_property_selection : EBSelection <Double> {
    return self.mValueFontSize_property.prop
  }

  //····················································································································
  //   Selection observable property: mValueRotation
  //····················································································································

  let mValueRotation_property = EBPropertyProxy_Int ()

  var mValueRotation_property_selection : EBSelection <Int> {
    return self.mValueRotation_property.prop
  }

  //····················································································································
  //   Selection observable property: mComponentValue
  //····················································································································

  let mComponentValue_property = EBPropertyProxy_String ()

  var mComponentValue_property_selection : EBSelection <String> {
    return self.mComponentValue_property.prop
  }

  //····················································································································
  //   Selection observable property: mNamePrefix
  //····················································································································

  let mNamePrefix_property = EBPropertyProxy_String ()

  var mNamePrefix_property_selection : EBSelection <String> {
    return self.mNamePrefix_property.prop
  }

  //····················································································································
  //   Selection observable property: mNameIndex
  //····················································································································

  let mNameIndex_property = EBPropertyProxy_Int ()

  var mNameIndex_property_selection : EBSelection <Int> {
    return self.mNameIndex_property.prop
  }

  //····················································································································
  //   Selection observable property: mXUnit
  //····················································································································

  let mXUnit_property = EBPropertyProxy_Int ()

  var mXUnit_property_selection : EBSelection <Int> {
    return self.mXUnit_property.prop
  }

  //····················································································································
  //   Selection observable property: mYUnit
  //····················································································································

  let mYUnit_property = EBPropertyProxy_Int ()

  var mYUnit_property_selection : EBSelection <Int> {
    return self.mYUnit_property.prop
  }

  //····················································································································
  //   ToMany proxy: mPackages
  //····················································································································

  let mPackages_property = ProxyArrayOf_DevicePackageInProject ()

  var mPackages_property_selection : EBSelection <[DevicePackageInProject]> {
    return .single (self.mPackages_property.propval)
  }

  //····················································································································
  //   Selection observable property: deviceName
  //····················································································································

  let deviceName_property = EBTransientProperty_String ()

  var deviceName_property_selection : EBSelection <String> {
    return self.deviceName_property.prop
  }

  //····················································································································
  //   Selection observable property: packagePadDictionary
  //····················································································································

  let packagePadDictionary_property = EBTransientProperty_PackageMasterPadDictionary ()

  var packagePadDictionary_property_selection : EBSelection <PackageMasterPadDictionary> {
    return self.packagePadDictionary_property.prop
  }

  //····················································································································
  //   Selection observable property: selectedPackageName
  //····················································································································

  let selectedPackageName_property = EBTransientProperty_String ()

  var selectedPackageName_property_selection : EBSelection <String> {
    return self.selectedPackageName_property.prop
  }

  //····················································································································
  //   Selection observable property: availablePackages
  //····················································································································

  let availablePackages_property = EBTransientProperty_StringArray ()

  var availablePackages_property_selection : EBSelection <StringArray> {
    return self.availablePackages_property.prop
  }

  //····················································································································
  //   Selection observable property: issues
  //····················································································································

  let issues_property = EBTransientProperty_CanariIssueArray ()

  var issues_property_selection : EBSelection <CanariIssueArray> {
    return self.issues_property.prop
  }

  //····················································································································
  //   Selection observable property: componentIsPlacedInBoard
  //····················································································································

  let componentIsPlacedInBoard_property = EBTransientProperty_Bool ()

  var componentIsPlacedInBoard_property_selection : EBSelection <Bool> {
    return self.componentIsPlacedInBoard_property.prop
  }

  //····················································································································
  //   Selection observable property: componentIsPlacedInBoardString
  //····················································································································

  let componentIsPlacedInBoardString_property = EBTransientProperty_String ()

  var componentIsPlacedInBoardString_property_selection : EBSelection <String> {
    return self.componentIsPlacedInBoardString_property.prop
  }

  //····················································································································
  //   Selection observable property: strokeBezierPath
  //····················································································································

  let strokeBezierPath_property = EBTransientProperty_EBBezierPath ()

  var strokeBezierPath_property_selection : EBSelection <EBBezierPath> {
    return self.strokeBezierPath_property.prop
  }

  //····················································································································
  //   Selection observable property: placementInSchematic
  //····················································································································

  let placementInSchematic_property = EBTransientProperty_String ()

  var placementInSchematic_property_selection : EBSelection <String> {
    return self.placementInSchematic_property.prop
  }

  //····················································································································
  //   Selection observable property: deviceSymbolDictionary
  //····················································································································

  let deviceSymbolDictionary_property = EBTransientProperty_DeviceSymbolDictionary ()

  var deviceSymbolDictionary_property_selection : EBSelection <DeviceSymbolDictionary> {
    return self.deviceSymbolDictionary_property.prop
  }

  //····················································································································
  //   Selection observable property: componentNameFontName
  //····················································································································

  let componentNameFontName_property = EBTransientProperty_String ()

  var componentNameFontName_property_selection : EBSelection <String> {
    return self.componentNameFontName_property.prop
  }

  //····················································································································
  //   Selection observable property: componentValueFontName
  //····················································································································

  let componentValueFontName_property = EBTransientProperty_String ()

  var componentValueFontName_property_selection : EBSelection <String> {
    return self.componentValueFontName_property.prop
  }

  //····················································································································
  //   Selection observable property: componentPadDictionary
  //····················································································································

  let componentPadDictionary_property = EBTransientProperty_ComponentPadDescriptorDictionary ()

  var componentPadDictionary_property_selection : EBSelection <ComponentPadDescriptorDictionary> {
    return self.componentPadDictionary_property.prop
  }

  //····················································································································
  //   Selection observable property: padNetDictionary
  //····················································································································

  let padNetDictionary_property = EBTransientProperty_PadNetDictionary ()

  var padNetDictionary_property_selection : EBSelection <PadNetDictionary> {
    return self.padNetDictionary_property.prop
  }

  //····················································································································
  //   Selection observable property: componentName
  //····················································································································

  let componentName_property = EBTransientProperty_String ()

  var componentName_property_selection : EBSelection <String> {
    return self.componentName_property.prop
  }

  //····················································································································
  //   Selection observable property: selectionDisplay
  //····················································································································

  let selectionDisplay_property = EBTransientProperty_EBShape ()

  var selectionDisplay_property_selection : EBSelection <EBShape> {
    return self.selectionDisplay_property.prop
  }

  //····················································································································
  //   Selection observable property: unplacedSymbols
  //····················································································································

  let unplacedSymbols_property = EBTransientProperty_StringTagArray ()

  var unplacedSymbols_property_selection : EBSelection <StringTagArray> {
    return self.unplacedSymbols_property.prop
  }

  //····················································································································
  //   Selection observable property: objectDisplay
  //····················································································································

  let objectDisplay_property = EBTransientProperty_EBShape ()

  var objectDisplay_property_selection : EBSelection <EBShape> {
    return self.objectDisplay_property.prop
  }

  //····················································································································
  //   Selected array (not observable)
  //····················································································································

  var selectedArray : [ComponentInProject] { return self.selectedArray_property.propval }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

   let selectedArray_property = TransientArrayOfSuperOf_ComponentInProject <BoardObject> ()

  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_BoardObject, file : String, line : Int) {
    self.selectedArray_property.setDataProvider (model)
    self.bind_property_mX ()
    self.bind_property_mY ()
    self.bind_property_mRotation ()
    self.bind_property_mSide ()
    self.bind_property_mNameIsVisibleInBoard ()
    self.bind_property_mXName ()
    self.bind_property_mYName ()
    self.bind_property_mNameFontSize ()
    self.bind_property_mNameRotation ()
    self.bind_property_mValueIsVisibleInBoard ()
    self.bind_property_mXValue ()
    self.bind_property_mYValue ()
    self.bind_property_mValueFontSize ()
    self.bind_property_mValueRotation ()
    self.bind_property_mComponentValue ()
    self.bind_property_mNamePrefix ()
    self.bind_property_mNameIndex ()
    self.bind_property_mXUnit ()
    self.bind_property_mYUnit ()
    self.bind_property_deviceName ()
    self.bind_property_packagePadDictionary ()
    self.bind_property_selectedPackageName ()
    self.bind_property_availablePackages ()
    self.bind_property_issues ()
    self.bind_property_componentIsPlacedInBoard ()
    self.bind_property_componentIsPlacedInBoardString ()
    self.bind_property_strokeBezierPath ()
    self.bind_property_placementInSchematic ()
    self.bind_property_deviceSymbolDictionary ()
    self.bind_property_componentNameFontName ()
    self.bind_property_componentValueFontName ()
    self.bind_property_componentPadDictionary ()
    self.bind_property_padNetDictionary ()
    self.bind_property_componentName ()
    self.bind_property_selectionDisplay ()
    self.bind_property_unplacedSymbols ()
    self.bind_property_objectDisplay ()
  }

  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
    self.selectedArray_property.setDataProvider (nil)
  //--- mX
    self.mX_property.mReadModelFunction = nil 
    self.mX_property.mWriteModelFunction = nil 
    self.mX_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mX (self.mX_property)
  //--- mY
    self.mY_property.mReadModelFunction = nil 
    self.mY_property.mWriteModelFunction = nil 
    self.mY_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mY (self.mY_property)
  //--- mRotation
    self.mRotation_property.mReadModelFunction = nil 
    self.mRotation_property.mWriteModelFunction = nil 
    self.mRotation_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mRotation (self.mRotation_property)
  //--- mSide
    self.mSide_property.mReadModelFunction = nil 
    self.mSide_property.mWriteModelFunction = nil 
    self.mSide_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mSide (self.mSide_property)
  //--- mNameIsVisibleInBoard
    self.mNameIsVisibleInBoard_property.mReadModelFunction = nil 
    self.mNameIsVisibleInBoard_property.mWriteModelFunction = nil 
    self.mNameIsVisibleInBoard_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameIsVisibleInBoard (self.mNameIsVisibleInBoard_property)
  //--- mXName
    self.mXName_property.mReadModelFunction = nil 
    self.mXName_property.mWriteModelFunction = nil 
    self.mXName_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mXName (self.mXName_property)
  //--- mYName
    self.mYName_property.mReadModelFunction = nil 
    self.mYName_property.mWriteModelFunction = nil 
    self.mYName_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mYName (self.mYName_property)
  //--- mNameFontSize
    self.mNameFontSize_property.mReadModelFunction = nil 
    self.mNameFontSize_property.mWriteModelFunction = nil 
    self.mNameFontSize_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameFontSize (self.mNameFontSize_property)
  //--- mNameRotation
    self.mNameRotation_property.mReadModelFunction = nil 
    self.mNameRotation_property.mWriteModelFunction = nil 
    self.mNameRotation_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameRotation (self.mNameRotation_property)
  //--- mValueIsVisibleInBoard
    self.mValueIsVisibleInBoard_property.mReadModelFunction = nil 
    self.mValueIsVisibleInBoard_property.mWriteModelFunction = nil 
    self.mValueIsVisibleInBoard_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mValueIsVisibleInBoard (self.mValueIsVisibleInBoard_property)
  //--- mXValue
    self.mXValue_property.mReadModelFunction = nil 
    self.mXValue_property.mWriteModelFunction = nil 
    self.mXValue_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mXValue (self.mXValue_property)
  //--- mYValue
    self.mYValue_property.mReadModelFunction = nil 
    self.mYValue_property.mWriteModelFunction = nil 
    self.mYValue_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mYValue (self.mYValue_property)
  //--- mValueFontSize
    self.mValueFontSize_property.mReadModelFunction = nil 
    self.mValueFontSize_property.mWriteModelFunction = nil 
    self.mValueFontSize_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mValueFontSize (self.mValueFontSize_property)
  //--- mValueRotation
    self.mValueRotation_property.mReadModelFunction = nil 
    self.mValueRotation_property.mWriteModelFunction = nil 
    self.mValueRotation_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mValueRotation (self.mValueRotation_property)
  //--- mComponentValue
    self.mComponentValue_property.mReadModelFunction = nil 
    self.mComponentValue_property.mWriteModelFunction = nil 
    self.mComponentValue_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mComponentValue (self.mComponentValue_property)
  //--- mNamePrefix
    self.mNamePrefix_property.mReadModelFunction = nil 
    self.mNamePrefix_property.mWriteModelFunction = nil 
    self.mNamePrefix_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNamePrefix (self.mNamePrefix_property)
  //--- mNameIndex
    self.mNameIndex_property.mReadModelFunction = nil 
    self.mNameIndex_property.mWriteModelFunction = nil 
    self.mNameIndex_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameIndex (self.mNameIndex_property)
  //--- mXUnit
    self.mXUnit_property.mReadModelFunction = nil 
    self.mXUnit_property.mWriteModelFunction = nil 
    self.mXUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mXUnit (self.mXUnit_property)
  //--- mYUnit
    self.mYUnit_property.mReadModelFunction = nil 
    self.mYUnit_property.mWriteModelFunction = nil 
    self.mYUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mYUnit (self.mYUnit_property)
  //--- deviceName
    self.deviceName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_deviceName (self.deviceName_property)
  //--- packagePadDictionary
    self.packagePadDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_packagePadDictionary (self.packagePadDictionary_property)
  //--- selectedPackageName
    self.selectedPackageName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_selectedPackageName (self.selectedPackageName_property)
  //--- availablePackages
    self.availablePackages_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_availablePackages (self.availablePackages_property)
  //--- issues
    self.issues_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_issues (self.issues_property)
  //--- componentIsPlacedInBoard
    self.componentIsPlacedInBoard_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentIsPlacedInBoard (self.componentIsPlacedInBoard_property)
  //--- componentIsPlacedInBoardString
    self.componentIsPlacedInBoardString_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentIsPlacedInBoardString (self.componentIsPlacedInBoardString_property)
  //--- strokeBezierPath
    self.strokeBezierPath_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_strokeBezierPath (self.strokeBezierPath_property)
  //--- placementInSchematic
    self.placementInSchematic_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_placementInSchematic (self.placementInSchematic_property)
  //--- deviceSymbolDictionary
    self.deviceSymbolDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_deviceSymbolDictionary (self.deviceSymbolDictionary_property)
  //--- componentNameFontName
    self.componentNameFontName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentNameFontName (self.componentNameFontName_property)
  //--- componentValueFontName
    self.componentValueFontName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentValueFontName (self.componentValueFontName_property)
  //--- componentPadDictionary
    self.componentPadDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentPadDictionary (self.componentPadDictionary_property)
  //--- padNetDictionary
    self.padNetDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_padNetDictionary (self.padNetDictionary_property)
  //--- componentName
    self.componentName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentName (self.componentName_property)
  //--- selectionDisplay
    self.selectionDisplay_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_selectionDisplay (self.selectionDisplay_property)
  //--- unplacedSymbols
    self.unplacedSymbols_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_unplacedSymbols (self.unplacedSymbols_property)
  //--- objectDisplay
    self.objectDisplay_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_objectDisplay (self.objectDisplay_property)
  //---
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame: thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (ebObjectIndex) + " " + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_ProjectDocument_componentInBoardSelectionController.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    self.mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x: 20.0, y: 20.0, width: 10.0, height: 10.0)
    self.mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame: r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "mX",
      idx: self.mX_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mX_property.mObserverExplorer,
      valueExplorer: &self.mX_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mY",
      idx: self.mY_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mY_property.mObserverExplorer,
      valueExplorer: &self.mY_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mRotation",
      idx: self.mRotation_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mRotation_property.mObserverExplorer,
      valueExplorer: &self.mRotation_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mSide",
      idx: self.mSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mSide_property.mObserverExplorer,
      valueExplorer: &self.mSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameIsVisibleInBoard",
      idx: self.mNameIsVisibleInBoard_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameIsVisibleInBoard_property.mObserverExplorer,
      valueExplorer: &self.mNameIsVisibleInBoard_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mXName",
      idx: self.mXName_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mXName_property.mObserverExplorer,
      valueExplorer: &self.mXName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mYName",
      idx: self.mYName_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mYName_property.mObserverExplorer,
      valueExplorer: &self.mYName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameFontSize",
      idx: self.mNameFontSize_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameFontSize_property.mObserverExplorer,
      valueExplorer: &self.mNameFontSize_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameRotation",
      idx: self.mNameRotation_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameRotation_property.mObserverExplorer,
      valueExplorer: &self.mNameRotation_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mValueIsVisibleInBoard",
      idx: self.mValueIsVisibleInBoard_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mValueIsVisibleInBoard_property.mObserverExplorer,
      valueExplorer: &self.mValueIsVisibleInBoard_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mXValue",
      idx: self.mXValue_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mXValue_property.mObserverExplorer,
      valueExplorer: &self.mXValue_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mYValue",
      idx: self.mYValue_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mYValue_property.mObserverExplorer,
      valueExplorer: &self.mYValue_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mValueFontSize",
      idx: self.mValueFontSize_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mValueFontSize_property.mObserverExplorer,
      valueExplorer: &self.mValueFontSize_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mValueRotation",
      idx: self.mValueRotation_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mValueRotation_property.mObserverExplorer,
      valueExplorer: &self.mValueRotation_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mComponentValue",
      idx: self.mComponentValue_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mComponentValue_property.mObserverExplorer,
      valueExplorer: &self.mComponentValue_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNamePrefix",
      idx: self.mNamePrefix_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNamePrefix_property.mObserverExplorer,
      valueExplorer: &self.mNamePrefix_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameIndex",
      idx: self.mNameIndex_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameIndex_property.mObserverExplorer,
      valueExplorer: &self.mNameIndex_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mXUnit",
      idx: self.mXUnit_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mXUnit_property.mObserverExplorer,
      valueExplorer: &self.mXUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mYUnit",
      idx: self.mYUnit_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mYUnit_property.mObserverExplorer,
      valueExplorer: &self.mYUnit_property.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x: 0.0, y: 0.0, width: EXPLORER_ROW_WIDTH, height: y)
    view.frame = viewFrame
  //--- Set content size
    self.mExplorerWindow?.setContentSize (NSSize (width: EXPLORER_ROW_WIDTH + 16.0, height: fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = self.mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_ProjectDocument_componentInBoardSelectionController.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (ebObjectIndex) + " " + className
    self.mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x: 0.0, y: 0.0, width: EXPLORER_ROW_WIDTH, height: y)
    let sw = NSScrollView (frame: frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    self.mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  @objc func showObjectWindowFromExplorerButton (_ : Any) {
    if self.mExplorerWindow == nil {
      self.buildExplorerWindow ()
    }
    self.mExplorerWindow?.makeKeyAndOrderFront (nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  @objc func deleteSelectionControllerWindowAction (_ : Any) {
    self.clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    if let closeButton = self.mExplorerWindow?.standardWindowButton (.closeButton) {
      closeButton.target = nil
    }
    self.mExplorerWindow?.orderOut (nil)
    self.mExplorerWindow = nil
  }

  //····················································································································

  private final func bind_property_mX () {
    self.selectedArray_property.addEBObserverOf_mX (self.mX_property, postEvent: true)
    self.mX_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mX_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mX_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mX_property.setProp (inValue)
          }
        }
      }
    }
    self.mX_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mX_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mY () {
    self.selectedArray_property.addEBObserverOf_mY (self.mY_property, postEvent: true)
    self.mY_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mY_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mY_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mY_property.setProp (inValue)
          }
        }
      }
    }
    self.mY_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mY_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mRotation () {
    self.selectedArray_property.addEBObserverOf_mRotation (self.mRotation_property, postEvent: true)
    self.mRotation_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mRotation_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mRotation_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mRotation_property.setProp (inValue)
          }
        }
      }
    }
    self.mRotation_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mRotation_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mSide () {
    self.selectedArray_property.addEBObserverOf_mSide (self.mSide_property, postEvent: true)
    self.mSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <ComponentSide> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mSide_property.mWriteModelFunction = { [weak self] (inValue : ComponentSide) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mSide_property.setProp (inValue)
          }
        }
      }
    }
    self.mSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : ComponentSide, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameIsVisibleInBoard () {
    self.selectedArray_property.addEBObserverOf_mNameIsVisibleInBoard (self.mNameIsVisibleInBoard_property, postEvent: true)
    self.mNameIsVisibleInBoard_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameIsVisibleInBoard_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameIsVisibleInBoard_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameIsVisibleInBoard_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameIsVisibleInBoard_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameIsVisibleInBoard_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mXName () {
    self.selectedArray_property.addEBObserverOf_mXName (self.mXName_property, postEvent: true)
    self.mXName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mXName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mXName_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mXName_property.setProp (inValue)
          }
        }
      }
    }
    self.mXName_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mXName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mYName () {
    self.selectedArray_property.addEBObserverOf_mYName (self.mYName_property, postEvent: true)
    self.mYName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mYName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mYName_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mYName_property.setProp (inValue)
          }
        }
      }
    }
    self.mYName_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mYName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameFontSize () {
    self.selectedArray_property.addEBObserverOf_mNameFontSize (self.mNameFontSize_property, postEvent: true)
    self.mNameFontSize_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Double> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameFontSize_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameFontSize_property.mWriteModelFunction = { [weak self] (inValue : Double) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameFontSize_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameFontSize_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Double, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameFontSize_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameRotation () {
    self.selectedArray_property.addEBObserverOf_mNameRotation (self.mNameRotation_property, postEvent: true)
    self.mNameRotation_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameRotation_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameRotation_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameRotation_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameRotation_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameRotation_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mValueIsVisibleInBoard () {
    self.selectedArray_property.addEBObserverOf_mValueIsVisibleInBoard (self.mValueIsVisibleInBoard_property, postEvent: true)
    self.mValueIsVisibleInBoard_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mValueIsVisibleInBoard_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mValueIsVisibleInBoard_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mValueIsVisibleInBoard_property.setProp (inValue)
          }
        }
      }
    }
    self.mValueIsVisibleInBoard_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mValueIsVisibleInBoard_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mXValue () {
    self.selectedArray_property.addEBObserverOf_mXValue (self.mXValue_property, postEvent: true)
    self.mXValue_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mXValue_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mXValue_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mXValue_property.setProp (inValue)
          }
        }
      }
    }
    self.mXValue_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mXValue_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mYValue () {
    self.selectedArray_property.addEBObserverOf_mYValue (self.mYValue_property, postEvent: true)
    self.mYValue_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mYValue_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mYValue_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mYValue_property.setProp (inValue)
          }
        }
      }
    }
    self.mYValue_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mYValue_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mValueFontSize () {
    self.selectedArray_property.addEBObserverOf_mValueFontSize (self.mValueFontSize_property, postEvent: true)
    self.mValueFontSize_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Double> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mValueFontSize_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mValueFontSize_property.mWriteModelFunction = { [weak self] (inValue : Double) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mValueFontSize_property.setProp (inValue)
          }
        }
      }
    }
    self.mValueFontSize_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Double, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mValueFontSize_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mValueRotation () {
    self.selectedArray_property.addEBObserverOf_mValueRotation (self.mValueRotation_property, postEvent: true)
    self.mValueRotation_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mValueRotation_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mValueRotation_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mValueRotation_property.setProp (inValue)
          }
        }
      }
    }
    self.mValueRotation_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mValueRotation_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mComponentValue () {
    self.selectedArray_property.addEBObserverOf_mComponentValue (self.mComponentValue_property, postEvent: true)
    self.mComponentValue_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mComponentValue_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mComponentValue_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mComponentValue_property.setProp (inValue)
          }
        }
      }
    }
    self.mComponentValue_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mComponentValue_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNamePrefix () {
    self.selectedArray_property.addEBObserverOf_mNamePrefix (self.mNamePrefix_property, postEvent: true)
    self.mNamePrefix_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNamePrefix_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNamePrefix_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNamePrefix_property.setProp (inValue)
          }
        }
      }
    }
    self.mNamePrefix_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNamePrefix_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameIndex () {
    self.selectedArray_property.addEBObserverOf_mNameIndex (self.mNameIndex_property, postEvent: true)
    self.mNameIndex_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameIndex_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameIndex_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameIndex_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameIndex_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameIndex_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mXUnit () {
    self.selectedArray_property.addEBObserverOf_mXUnit (self.mXUnit_property, postEvent: true)
    self.mXUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mXUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mXUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mXUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mXUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mXUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mYUnit () {
    self.selectedArray_property.addEBObserverOf_mYUnit (self.mYUnit_property, postEvent: true)
    self.mYUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mYUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mYUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mYUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mYUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mYUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_deviceName () {
    self.selectedArray_property.addEBObserverOf_deviceName (self.deviceName_property, postEvent: true)
    self.deviceName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.deviceName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_packagePadDictionary () {
    self.selectedArray_property.addEBObserverOf_packagePadDictionary (self.packagePadDictionary_property, postEvent: true)
    self.packagePadDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <PackageMasterPadDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.packagePadDictionary_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_selectedPackageName () {
    self.selectedArray_property.addEBObserverOf_selectedPackageName (self.selectedPackageName_property, postEvent: true)
    self.selectedPackageName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.selectedPackageName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_availablePackages () {
    self.selectedArray_property.addEBObserverOf_availablePackages (self.availablePackages_property, postEvent: true)
    self.availablePackages_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <StringArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.availablePackages_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_issues () {
    self.selectedArray_property.addEBObserverOf_issues (self.issues_property, postEvent: true)
    self.issues_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <CanariIssueArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.issues_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentIsPlacedInBoard () {
    self.selectedArray_property.addEBObserverOf_componentIsPlacedInBoard (self.componentIsPlacedInBoard_property, postEvent: true)
    self.componentIsPlacedInBoard_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentIsPlacedInBoard_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentIsPlacedInBoardString () {
    self.selectedArray_property.addEBObserverOf_componentIsPlacedInBoardString (self.componentIsPlacedInBoardString_property, postEvent: true)
    self.componentIsPlacedInBoardString_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentIsPlacedInBoardString_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_strokeBezierPath () {
    self.selectedArray_property.addEBObserverOf_strokeBezierPath (self.strokeBezierPath_property, postEvent: true)
    self.strokeBezierPath_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBBezierPath> ()
          var isMultipleSelection = false
          for object in v {
            switch object.strokeBezierPath_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_placementInSchematic () {
    self.selectedArray_property.addEBObserverOf_placementInSchematic (self.placementInSchematic_property, postEvent: true)
    self.placementInSchematic_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.placementInSchematic_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_deviceSymbolDictionary () {
    self.selectedArray_property.addEBObserverOf_deviceSymbolDictionary (self.deviceSymbolDictionary_property, postEvent: true)
    self.deviceSymbolDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <DeviceSymbolDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.deviceSymbolDictionary_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentNameFontName () {
    self.selectedArray_property.addEBObserverOf_componentNameFontName (self.componentNameFontName_property, postEvent: true)
    self.componentNameFontName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentNameFontName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentValueFontName () {
    self.selectedArray_property.addEBObserverOf_componentValueFontName (self.componentValueFontName_property, postEvent: true)
    self.componentValueFontName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentValueFontName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentPadDictionary () {
    self.selectedArray_property.addEBObserverOf_componentPadDictionary (self.componentPadDictionary_property, postEvent: true)
    self.componentPadDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <ComponentPadDescriptorDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentPadDictionary_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_padNetDictionary () {
    self.selectedArray_property.addEBObserverOf_padNetDictionary (self.padNetDictionary_property, postEvent: true)
    self.padNetDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <PadNetDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padNetDictionary_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentName () {
    self.selectedArray_property.addEBObserverOf_componentName (self.componentName_property, postEvent: true)
    self.componentName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_selectionDisplay () {
    self.selectedArray_property.addEBObserverOf_selectionDisplay (self.selectionDisplay_property, postEvent: true)
    self.selectionDisplay_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBShape> ()
          var isMultipleSelection = false
          for object in v {
            switch object.selectionDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_unplacedSymbols () {
    self.selectedArray_property.addEBObserverOf_unplacedSymbols (self.unplacedSymbols_property, postEvent: true)
    self.unplacedSymbols_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <StringTagArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.unplacedSymbols_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_objectDisplay () {
    self.selectedArray_property.addEBObserverOf_objectDisplay (self.objectDisplay_property, postEvent: true)
    self.objectDisplay_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBShape> ()
          var isMultipleSelection = false
          for object in v {
            switch object.objectDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }


  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

