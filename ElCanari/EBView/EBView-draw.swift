//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate let SHOW_OBJECT_BOUNDING_BOXES = false
fileprivate let SHOW_KNOB_BOUNDING_BOXES = false

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBView
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension EBView {

  //····················································································································
  // MARK: -
  //····················································································································

  override func draw (_ inDirtyRect: NSRect) {
    self.mBackColor.setFill ()
    NSBezierPath.fill (inDirtyRect)
    self.drawGrid (inDirtyRect)
    self.mUnderObjectsDisplay.draw (self, inDirtyRect)
    for object in self.objectDisplayArray {
      object.draw (self, inDirtyRect)
    }
    self.mOverObjectsDisplay.draw (self, inDirtyRect)
    for shape in self.selectionShapes {
      shape.draw (self, inDirtyRect)
    }
    self.drawIssue (inDirtyRect)
    self.drawGuideBezierPath (inDirtyRect)
    self.selectionRectangleLayer?.draw (self, inDirtyRect)
  //--- DEBUG
    if SHOW_OBJECT_BOUNDING_BOXES {
      NSColor.black.setStroke ()
      NSBezierPath.defaultLineWidth = 1.0
      for shape in self.objectDisplayArray {
        let r = shape.boundingBox.insetBy(dx: 0.5, dy: 0.5)
        NSBezierPath.stroke (r)
      }
    }
    if SHOW_KNOB_BOUNDING_BOXES {
      NSColor.black.setStroke ()
      NSBezierPath.defaultLineWidth = 1.0
      for shape in self.selectionShapes {
        let r = shape.boundingBox.insetBy(dx: 0.5, dy: 0.5)
        NSBezierPath.stroke (r)
      }
    }
  }

  //····················································································································

  fileprivate func drawGrid (_ inDirtyRect: NSRect) {
    let r = inDirtyRect
    let gridDisplayStep = self.mGridStep * CGFloat (self.mGridStepFactor)
    let startX = (r.origin.x / gridDisplayStep).rounded (.down) * gridDisplayStep
    let endX = r.maxX
    let startY = (r.origin.y / gridDisplayStep).rounded (.down) * gridDisplayStep
    let endY = r.maxY
    let displayOffset = 0.5 / self.actualScale
    switch self.mGridStyle {
    case .noGrid :
      ()
    case .cross :
      let bp = NSBezierPath ()
      bp.lineWidth = 0.0
      bp.lineCapStyle = .round
      var x = startX
      while x <= endX {
        var y = startY
        while y <= endY {
          bp.move (to: NSPoint (x: x - 0.5 + displayOffset, y: y + displayOffset))
          bp.line (to: NSPoint (x: x + 0.5 + displayOffset, y: y + displayOffset))
          bp.move (to: NSPoint (x: x + displayOffset,       y: y + 0.5 + displayOffset))
          bp.line (to: NSPoint (x: x + displayOffset,       y: y - 0.5 + displayOffset))
          y += gridDisplayStep
        }
        x += gridDisplayStep
      }
      self.mGridCrossColor.setStroke ()
      bp.stroke ()
    case .line :
      let bp = NSBezierPath ()
      bp.lineWidth = 0.0
      bp.lineCapStyle = .round
      var x = startX
      while x <= r.maxX {
        let p1 = NSPoint (x: x + displayOffset, y: startY + displayOffset)
        let p2 = NSPoint (x: x + displayOffset, y: endY + displayOffset)
        bp.move (to: p1)
        bp.line (to: p2)
        x += gridDisplayStep
      }
      var y = startY
      while y <= endY {
        bp.move (to: NSPoint (x: startX + displayOffset, y: y + displayOffset))
        bp.line (to: NSPoint (x: endX   + displayOffset, y: y + displayOffset))
        y += gridDisplayStep
      }
      self.mGridLineColor.setStroke ()
      bp.stroke ()
    }
  }

  //····················································································································
  // MARK: -
  //····················································································································

  internal func noteInvalidRectangles (old inOldShape : EBShape, new inNewShape : EBShape) {
    if inOldShape != inNewShape {
      self.setNeedsDisplay (inNewShape.boundingBox)
      self.setNeedsDisplay (inOldShape.boundingBox)
    }
  }

  //····················································································································

  internal func noteInvalidRectangles (old inOldShapes : [EBShape], new inNewShapes : [EBShape]) {
    // Swift.print ("noteInvalidRectangles")
    let minCount = min (inOldShapes.count, inNewShapes.count)
    var idx = 0
    while idx < minCount {
      if inNewShapes [idx] != inOldShapes [idx] {
        // Swift.print ("  object \(idx): \(inNewShapes [idx].boundingBox) -> \(inOldShapes [idx].boundingBox)")
        self.setNeedsDisplay (inNewShapes [idx].boundingBox)
        self.setNeedsDisplay (inOldShapes [idx].boundingBox)
      }
      idx += 1
    }
    while idx < inOldShapes.count {
      // Swift.print ("  old object \(idx)")
      self.setNeedsDisplay (inOldShapes [idx].boundingBox)
      idx += 1
    }
    while idx < inNewShapes.count {
      // Swift.print ("  new object \(idx)")
      self.setNeedsDisplay (inNewShapes [idx].boundingBox)
      idx += 1
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

