//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    SelectionController_PMArtworkDocument_mDataSelection                                                             *
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(SelectionController_PMArtworkDocument_mDataSelection)
final class SelectionController_PMArtworkDocument_mDataSelection : EBObject {
  private var mModel : ReadOnlyArrayOf_ArtworkFileGenerationParameters?

  //····················································································································
  //   SELECTION OBSERVABLE PROPERTIES
  //····················································································································

  var drawBoardLimits = EBPropertyProxy_Bool () 
  var drawComponentNamesBottomSide = EBPropertyProxy_Bool () 
  var drawComponentNamesTopSide = EBPropertyProxy_Bool () 
  var drawComponentValuesBottomSide = EBPropertyProxy_Bool () 
  var drawComponentValuesTopSide = EBPropertyProxy_Bool () 
  var drawPackageLegendBottomSide = EBPropertyProxy_Bool () 
  var drawPackageLegendTopSide = EBPropertyProxy_Bool () 
  var drawPadHolesInPDF = EBPropertyProxy_Bool () 
  var drawPadsBottomSide = EBPropertyProxy_Bool () 
  var drawPadsTopSide = EBPropertyProxy_Bool () 
  var drawTextsLayoutBottomSide = EBPropertyProxy_Bool () 
  var drawTextsLayoutTopSide = EBPropertyProxy_Bool () 
  var drawTextsLegendBottomSide = EBPropertyProxy_Bool () 
  var drawTextsLegendTopSide = EBPropertyProxy_Bool () 
  var drawTracksBottomSide = EBPropertyProxy_Bool () 
  var drawTracksTopSide = EBPropertyProxy_Bool () 
  var drawVias = EBPropertyProxy_Bool () 
  var fileExtension = EBPropertyProxy_String () 
  var horizontalMirror = EBPropertyProxy_Bool () 
  var measurementUnitForPadHoleInPDF = EBPropertyProxy_Int () 
  var name = EBPropertyProxy_String () 
  var padHoleDiameterInPDF = EBPropertyProxy_Int () 

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters, file:String, line:Int) {
    mModel = model
    bind_property_drawBoardLimits (model: model)
    bind_property_drawComponentNamesBottomSide (model: model)
    bind_property_drawComponentNamesTopSide (model: model)
    bind_property_drawComponentValuesBottomSide (model: model)
    bind_property_drawComponentValuesTopSide (model: model)
    bind_property_drawPackageLegendBottomSide (model: model)
    bind_property_drawPackageLegendTopSide (model: model)
    bind_property_drawPadHolesInPDF (model: model)
    bind_property_drawPadsBottomSide (model: model)
    bind_property_drawPadsTopSide (model: model)
    bind_property_drawTextsLayoutBottomSide (model: model)
    bind_property_drawTextsLayoutTopSide (model: model)
    bind_property_drawTextsLegendBottomSide (model: model)
    bind_property_drawTextsLegendTopSide (model: model)
    bind_property_drawTracksBottomSide (model: model)
    bind_property_drawTracksTopSide (model: model)
    bind_property_drawVias (model: model)
    bind_property_fileExtension (model: model)
    bind_property_horizontalMirror (model: model)
    bind_property_measurementUnitForPadHoleInPDF (model: model)
    bind_property_name (model: model)
    bind_property_padHoleDiameterInPDF (model: model)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize ())
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame:thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (mEasyBindingsObjectIndex) + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_PMArtworkDocument_mDataSelection.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
    mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame:r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "drawBoardLimits",
      idx:drawBoardLimits.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawBoardLimits.mObserverExplorer,
      valueExplorer:&drawBoardLimits.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentNamesBottomSide",
      idx:drawComponentNamesBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawComponentNamesBottomSide.mObserverExplorer,
      valueExplorer:&drawComponentNamesBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentNamesTopSide",
      idx:drawComponentNamesTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawComponentNamesTopSide.mObserverExplorer,
      valueExplorer:&drawComponentNamesTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentValuesBottomSide",
      idx:drawComponentValuesBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawComponentValuesBottomSide.mObserverExplorer,
      valueExplorer:&drawComponentValuesBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentValuesTopSide",
      idx:drawComponentValuesTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawComponentValuesTopSide.mObserverExplorer,
      valueExplorer:&drawComponentValuesTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPackageLegendBottomSide",
      idx:drawPackageLegendBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawPackageLegendBottomSide.mObserverExplorer,
      valueExplorer:&drawPackageLegendBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPackageLegendTopSide",
      idx:drawPackageLegendTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawPackageLegendTopSide.mObserverExplorer,
      valueExplorer:&drawPackageLegendTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadHolesInPDF",
      idx:drawPadHolesInPDF.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawPadHolesInPDF.mObserverExplorer,
      valueExplorer:&drawPadHolesInPDF.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadsBottomSide",
      idx:drawPadsBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawPadsBottomSide.mObserverExplorer,
      valueExplorer:&drawPadsBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadsTopSide",
      idx:drawPadsTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawPadsTopSide.mObserverExplorer,
      valueExplorer:&drawPadsTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLayoutBottomSide",
      idx:drawTextsLayoutBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawTextsLayoutBottomSide.mObserverExplorer,
      valueExplorer:&drawTextsLayoutBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLayoutTopSide",
      idx:drawTextsLayoutTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawTextsLayoutTopSide.mObserverExplorer,
      valueExplorer:&drawTextsLayoutTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLegendBottomSide",
      idx:drawTextsLegendBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawTextsLegendBottomSide.mObserverExplorer,
      valueExplorer:&drawTextsLegendBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLegendTopSide",
      idx:drawTextsLegendTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawTextsLegendTopSide.mObserverExplorer,
      valueExplorer:&drawTextsLegendTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTracksBottomSide",
      idx:drawTracksBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawTracksBottomSide.mObserverExplorer,
      valueExplorer:&drawTracksBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTracksTopSide",
      idx:drawTracksTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawTracksTopSide.mObserverExplorer,
      valueExplorer:&drawTracksTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawVias",
      idx:drawVias.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&drawVias.mObserverExplorer,
      valueExplorer:&drawVias.mValueExplorer
    )
    createEntryForPropertyNamed (
      "fileExtension",
      idx:fileExtension.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&fileExtension.mObserverExplorer,
      valueExplorer:&fileExtension.mValueExplorer
    )
    createEntryForPropertyNamed (
      "horizontalMirror",
      idx:horizontalMirror.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&horizontalMirror.mObserverExplorer,
      valueExplorer:&horizontalMirror.mValueExplorer
    )
    createEntryForPropertyNamed (
      "measurementUnitForPadHoleInPDF",
      idx:measurementUnitForPadHoleInPDF.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&measurementUnitForPadHoleInPDF.mObserverExplorer,
      valueExplorer:&measurementUnitForPadHoleInPDF.mValueExplorer
    )
    createEntryForPropertyNamed (
      "name",
      idx:name.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&name.mObserverExplorer,
      valueExplorer:&name.mValueExplorer
    )
    createEntryForPropertyNamed (
      "padHoleDiameterInPDF",
      idx:padHoleDiameterInPDF.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&padHoleDiameterInPDF.mObserverExplorer,
      valueExplorer:&padHoleDiameterInPDF.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    view.frame = viewFrame
  //--- Set content size
    mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_PMArtworkDocument_mDataSelection.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (mEasyBindingsObjectIndex) + className
    mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    let sw = NSScrollView (frame:frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  func showObjectWindowFromExplorerButton (_ : Any) {
    if mExplorerWindow == nil {
      buildExplorerWindow ()
    }
    mExplorerWindow?.makeKeyAndOrderFront(nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  func deleteSelectionControllerWindowAction (_ : Any) {
    clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton!.target = nil
    mExplorerWindow?.orderOut (nil)
    mExplorerWindow = nil
  }

  //···················································································································*

  private final func bind_property_drawBoardLimits (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawBoardLimits (drawBoardLimits)
    drawBoardLimits.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawBoardLimits.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawBoardLimits.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawBoardLimits.setProp (inValue)
          }
        }
      }
    }
    drawBoardLimits.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawBoardLimits.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesBottomSide (drawComponentNamesBottomSide)
    drawComponentNamesBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawComponentNamesBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawComponentNamesBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawComponentNamesBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawComponentNamesBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesTopSide (drawComponentNamesTopSide)
    drawComponentNamesTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawComponentNamesTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawComponentNamesTopSide.setProp (inValue)
          }
        }
      }
    }
    drawComponentNamesTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawComponentNamesTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesBottomSide (drawComponentValuesBottomSide)
    drawComponentValuesBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawComponentValuesBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawComponentValuesBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawComponentValuesBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawComponentValuesBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesTopSide (drawComponentValuesTopSide)
    drawComponentValuesTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawComponentValuesTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawComponentValuesTopSide.setProp (inValue)
          }
        }
      }
    }
    drawComponentValuesTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawComponentValuesTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendBottomSide (drawPackageLegendBottomSide)
    drawPackageLegendBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawPackageLegendBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawPackageLegendBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawPackageLegendBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawPackageLegendBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendTopSide (drawPackageLegendTopSide)
    drawPackageLegendTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawPackageLegendTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawPackageLegendTopSide.setProp (inValue)
          }
        }
      }
    }
    drawPackageLegendTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawPackageLegendTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadHolesInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadHolesInPDF (drawPadHolesInPDF)
    drawPadHolesInPDF.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadHolesInPDF.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawPadHolesInPDF.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawPadHolesInPDF.setProp (inValue)
          }
        }
      }
    }
    drawPadHolesInPDF.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawPadHolesInPDF.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsBottomSide (drawPadsBottomSide)
    drawPadsBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawPadsBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawPadsBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawPadsBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawPadsBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsTopSide (drawPadsTopSide)
    drawPadsTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawPadsTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawPadsTopSide.setProp (inValue)
          }
        }
      }
    }
    drawPadsTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawPadsTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutBottomSide (drawTextsLayoutBottomSide)
    drawTextsLayoutBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawTextsLayoutBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawTextsLayoutBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawTextsLayoutBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawTextsLayoutBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutTopSide (drawTextsLayoutTopSide)
    drawTextsLayoutTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawTextsLayoutTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawTextsLayoutTopSide.setProp (inValue)
          }
        }
      }
    }
    drawTextsLayoutTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawTextsLayoutTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendBottomSide (drawTextsLegendBottomSide)
    drawTextsLegendBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawTextsLegendBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawTextsLegendBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawTextsLegendBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawTextsLegendBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendTopSide (drawTextsLegendTopSide)
    drawTextsLegendTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawTextsLegendTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawTextsLegendTopSide.setProp (inValue)
          }
        }
      }
    }
    drawTextsLegendTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawTextsLegendTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksBottomSide (drawTracksBottomSide)
    drawTracksBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksBottomSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawTracksBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawTracksBottomSide.setProp (inValue)
          }
        }
      }
    }
    drawTracksBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawTracksBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksTopSide (drawTracksTopSide)
    drawTracksTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksTopSide.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawTracksTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawTracksTopSide.setProp (inValue)
          }
        }
      }
    }
    drawTracksTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawTracksTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawVias (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawVias (drawVias)
    drawVias.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawVias.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    drawVias.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.drawVias.setProp (inValue)
          }
        }
      }
    }
    drawVias.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.drawVias.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_fileExtension (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_fileExtension (fileExtension)
    fileExtension.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.fileExtension.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    fileExtension.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.fileExtension.setProp (inValue)
          }
        }
      }
    }
    fileExtension.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.fileExtension.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_horizontalMirror (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_horizontalMirror (horizontalMirror)
    horizontalMirror.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.horizontalMirror.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    horizontalMirror.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.horizontalMirror.setProp (inValue)
          }
        }
      }
    }
    horizontalMirror.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.horizontalMirror.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_measurementUnitForPadHoleInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_measurementUnitForPadHoleInPDF (measurementUnitForPadHoleInPDF)
    measurementUnitForPadHoleInPDF.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.measurementUnitForPadHoleInPDF.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    measurementUnitForPadHoleInPDF.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.measurementUnitForPadHoleInPDF.setProp (inValue)
          }
        }
      }
    }
    measurementUnitForPadHoleInPDF.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.measurementUnitForPadHoleInPDF.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_name (name)
    name.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    name.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.name.setProp (inValue)
          }
        }
      }
    }
    name.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.name.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padHoleDiameterInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_padHoleDiameterInPDF (padHoleDiameterInPDF)
    padHoleDiameterInPDF.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .noSelection :
          return .noSelection
        case .multipleSelection :
          return .multipleSelection
        case .singleSelection (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padHoleDiameterInPDF.prop {
            case .noSelection :
              return .noSelection
            case .multipleSelection :
              isMultipleSelection = true
            case .singleSelection (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multipleSelection
          }else if s.count == 0 {
            return .noSelection
          }else if s.count == 1 {
            return .singleSelection (s.first!)
          }else{
            return .multipleSelection
          }
        }
      }else{
        return .noSelection
      }
    }
    padHoleDiameterInPDF.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          break
        case .singleSelection (let v) :
          for object in v {
            object.padHoleDiameterInPDF.setProp (inValue)
          }
        }
      }
    }
    padHoleDiameterInPDF.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .noSelection, .multipleSelection :
          return false
        case .singleSelection (let v) :
          for object in v {
            let result = object.padHoleDiameterInPDF.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }



  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
  //--- drawBoardLimits
    drawBoardLimits.readModelFunction = nil 
    drawBoardLimits.writeModelFunction = nil 
    drawBoardLimits.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawBoardLimits (drawBoardLimits)
//    mModel?.removeEBObserver (drawBoardLimits)
  //--- drawComponentNamesBottomSide
    drawComponentNamesBottomSide.readModelFunction = nil 
    drawComponentNamesBottomSide.writeModelFunction = nil 
    drawComponentNamesBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentNamesBottomSide (drawComponentNamesBottomSide)
//    mModel?.removeEBObserver (drawComponentNamesBottomSide)
  //--- drawComponentNamesTopSide
    drawComponentNamesTopSide.readModelFunction = nil 
    drawComponentNamesTopSide.writeModelFunction = nil 
    drawComponentNamesTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentNamesTopSide (drawComponentNamesTopSide)
//    mModel?.removeEBObserver (drawComponentNamesTopSide)
  //--- drawComponentValuesBottomSide
    drawComponentValuesBottomSide.readModelFunction = nil 
    drawComponentValuesBottomSide.writeModelFunction = nil 
    drawComponentValuesBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentValuesBottomSide (drawComponentValuesBottomSide)
//    mModel?.removeEBObserver (drawComponentValuesBottomSide)
  //--- drawComponentValuesTopSide
    drawComponentValuesTopSide.readModelFunction = nil 
    drawComponentValuesTopSide.writeModelFunction = nil 
    drawComponentValuesTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentValuesTopSide (drawComponentValuesTopSide)
//    mModel?.removeEBObserver (drawComponentValuesTopSide)
  //--- drawPackageLegendBottomSide
    drawPackageLegendBottomSide.readModelFunction = nil 
    drawPackageLegendBottomSide.writeModelFunction = nil 
    drawPackageLegendBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPackageLegendBottomSide (drawPackageLegendBottomSide)
//    mModel?.removeEBObserver (drawPackageLegendBottomSide)
  //--- drawPackageLegendTopSide
    drawPackageLegendTopSide.readModelFunction = nil 
    drawPackageLegendTopSide.writeModelFunction = nil 
    drawPackageLegendTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPackageLegendTopSide (drawPackageLegendTopSide)
//    mModel?.removeEBObserver (drawPackageLegendTopSide)
  //--- drawPadHolesInPDF
    drawPadHolesInPDF.readModelFunction = nil 
    drawPadHolesInPDF.writeModelFunction = nil 
    drawPadHolesInPDF.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPadHolesInPDF (drawPadHolesInPDF)
//    mModel?.removeEBObserver (drawPadHolesInPDF)
  //--- drawPadsBottomSide
    drawPadsBottomSide.readModelFunction = nil 
    drawPadsBottomSide.writeModelFunction = nil 
    drawPadsBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPadsBottomSide (drawPadsBottomSide)
//    mModel?.removeEBObserver (drawPadsBottomSide)
  //--- drawPadsTopSide
    drawPadsTopSide.readModelFunction = nil 
    drawPadsTopSide.writeModelFunction = nil 
    drawPadsTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPadsTopSide (drawPadsTopSide)
//    mModel?.removeEBObserver (drawPadsTopSide)
  //--- drawTextsLayoutBottomSide
    drawTextsLayoutBottomSide.readModelFunction = nil 
    drawTextsLayoutBottomSide.writeModelFunction = nil 
    drawTextsLayoutBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLayoutBottomSide (drawTextsLayoutBottomSide)
//    mModel?.removeEBObserver (drawTextsLayoutBottomSide)
  //--- drawTextsLayoutTopSide
    drawTextsLayoutTopSide.readModelFunction = nil 
    drawTextsLayoutTopSide.writeModelFunction = nil 
    drawTextsLayoutTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLayoutTopSide (drawTextsLayoutTopSide)
//    mModel?.removeEBObserver (drawTextsLayoutTopSide)
  //--- drawTextsLegendBottomSide
    drawTextsLegendBottomSide.readModelFunction = nil 
    drawTextsLegendBottomSide.writeModelFunction = nil 
    drawTextsLegendBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLegendBottomSide (drawTextsLegendBottomSide)
//    mModel?.removeEBObserver (drawTextsLegendBottomSide)
  //--- drawTextsLegendTopSide
    drawTextsLegendTopSide.readModelFunction = nil 
    drawTextsLegendTopSide.writeModelFunction = nil 
    drawTextsLegendTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLegendTopSide (drawTextsLegendTopSide)
//    mModel?.removeEBObserver (drawTextsLegendTopSide)
  //--- drawTracksBottomSide
    drawTracksBottomSide.readModelFunction = nil 
    drawTracksBottomSide.writeModelFunction = nil 
    drawTracksBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTracksBottomSide (drawTracksBottomSide)
//    mModel?.removeEBObserver (drawTracksBottomSide)
  //--- drawTracksTopSide
    drawTracksTopSide.readModelFunction = nil 
    drawTracksTopSide.writeModelFunction = nil 
    drawTracksTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTracksTopSide (drawTracksTopSide)
//    mModel?.removeEBObserver (drawTracksTopSide)
  //--- drawVias
    drawVias.readModelFunction = nil 
    drawVias.writeModelFunction = nil 
    drawVias.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawVias (drawVias)
//    mModel?.removeEBObserver (drawVias)
  //--- fileExtension
    fileExtension.readModelFunction = nil 
    fileExtension.writeModelFunction = nil 
    fileExtension.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_fileExtension (fileExtension)
//    mModel?.removeEBObserver (fileExtension)
  //--- horizontalMirror
    horizontalMirror.readModelFunction = nil 
    horizontalMirror.writeModelFunction = nil 
    horizontalMirror.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_horizontalMirror (horizontalMirror)
//    mModel?.removeEBObserver (horizontalMirror)
  //--- measurementUnitForPadHoleInPDF
    measurementUnitForPadHoleInPDF.readModelFunction = nil 
    measurementUnitForPadHoleInPDF.writeModelFunction = nil 
    measurementUnitForPadHoleInPDF.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_measurementUnitForPadHoleInPDF (measurementUnitForPadHoleInPDF)
//    mModel?.removeEBObserver (measurementUnitForPadHoleInPDF)
  //--- name
    name.readModelFunction = nil 
    name.writeModelFunction = nil 
    name.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_name (name)
//    mModel?.removeEBObserver (name)
  //--- padHoleDiameterInPDF
    padHoleDiameterInPDF.readModelFunction = nil 
    padHoleDiameterInPDF.writeModelFunction = nil 
    padHoleDiameterInPDF.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_padHoleDiameterInPDF (padHoleDiameterInPDF)
//    mModel?.removeEBObserver (padHoleDiameterInPDF)
    mModel = nil    
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

