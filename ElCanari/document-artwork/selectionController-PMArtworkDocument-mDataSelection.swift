//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    SelectionController_PMArtworkDocument_mDataSelection                                                             *
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(SelectionController_PMArtworkDocument_mDataSelection)
final class SelectionController_PMArtworkDocument_mDataSelection : EBObject {
  private var mModel : ReadOnlyArrayOf_ArtworkFileGenerationParameters?

  //····················································································································
  //   SELECTION OBSERVABLE PROPERTIES
  //····················································································································

  var drawBoardLimits = EBPropertyProxy_Bool () 
  var drawComponentNamesBottomSide = EBPropertyProxy_Bool () 
  var drawComponentNamesTopSide = EBPropertyProxy_Bool () 
  var drawComponentValuesBottomSide = EBPropertyProxy_Bool () 
  var drawComponentValuesTopSide = EBPropertyProxy_Bool () 
  var drawPackageLegendBottomSide = EBPropertyProxy_Bool () 
  var drawPackageLegendTopSide = EBPropertyProxy_Bool () 
  var drawPadHolesInPDF = EBPropertyProxy_Bool () 
  var drawPadsBottomSide = EBPropertyProxy_Bool () 
  var drawPadsTopSide = EBPropertyProxy_Bool () 
  var drawTextsLayoutBottomSide = EBPropertyProxy_Bool () 
  var drawTextsLayoutTopSide = EBPropertyProxy_Bool () 
  var drawTextsLegendBottomSide = EBPropertyProxy_Bool () 
  var drawTextsLegendTopSide = EBPropertyProxy_Bool () 
  var drawTracksBottomSide = EBPropertyProxy_Bool () 
  var drawTracksTopSide = EBPropertyProxy_Bool () 
  var drawVias = EBPropertyProxy_Bool () 
  var fileExtension = EBPropertyProxy_String () 
  var horizontalMirror = EBPropertyProxy_Bool () 
  var measurementUnitForPadHoleInPDF = EBPropertyProxy_Int () 
  var name = EBPropertyProxy_String () 
  var padHoleDiameterInPDF = EBPropertyProxy_Int () 

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters, file:String, line:Int) {
    mModel = model
    bind_property_drawBoardLimits (model: model)
    bind_property_drawComponentNamesBottomSide (model: model)
    bind_property_drawComponentNamesTopSide (model: model)
    bind_property_drawComponentValuesBottomSide (model: model)
    bind_property_drawComponentValuesTopSide (model: model)
    bind_property_drawPackageLegendBottomSide (model: model)
    bind_property_drawPackageLegendTopSide (model: model)
    bind_property_drawPadHolesInPDF (model: model)
    bind_property_drawPadsBottomSide (model: model)
    bind_property_drawPadsTopSide (model: model)
    bind_property_drawTextsLayoutBottomSide (model: model)
    bind_property_drawTextsLayoutTopSide (model: model)
    bind_property_drawTextsLegendBottomSide (model: model)
    bind_property_drawTextsLegendTopSide (model: model)
    bind_property_drawTracksBottomSide (model: model)
    bind_property_drawTracksTopSide (model: model)
    bind_property_drawVias (model: model)
    bind_property_fileExtension (model: model)
    bind_property_horizontalMirror (model: model)
    bind_property_measurementUnitForPadHoleInPDF (model: model)
    bind_property_name (model: model)
    bind_property_padHoleDiameterInPDF (model: model)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize ())
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame:thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (mEasyBindingsObjectIndex) + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_PMArtworkDocument_mDataSelection.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
    mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame:r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "drawBoardLimits",
      idx:self.drawBoardLimits.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawBoardLimits.mObserverExplorer,
      valueExplorer:&self.drawBoardLimits.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentNamesBottomSide",
      idx:self.drawComponentNamesBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawComponentNamesBottomSide.mObserverExplorer,
      valueExplorer:&self.drawComponentNamesBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentNamesTopSide",
      idx:self.drawComponentNamesTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawComponentNamesTopSide.mObserverExplorer,
      valueExplorer:&self.drawComponentNamesTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentValuesBottomSide",
      idx:self.drawComponentValuesBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawComponentValuesBottomSide.mObserverExplorer,
      valueExplorer:&self.drawComponentValuesBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentValuesTopSide",
      idx:self.drawComponentValuesTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawComponentValuesTopSide.mObserverExplorer,
      valueExplorer:&self.drawComponentValuesTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPackageLegendBottomSide",
      idx:self.drawPackageLegendBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawPackageLegendBottomSide.mObserverExplorer,
      valueExplorer:&self.drawPackageLegendBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPackageLegendTopSide",
      idx:self.drawPackageLegendTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawPackageLegendTopSide.mObserverExplorer,
      valueExplorer:&self.drawPackageLegendTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadHolesInPDF",
      idx:self.drawPadHolesInPDF.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawPadHolesInPDF.mObserverExplorer,
      valueExplorer:&self.drawPadHolesInPDF.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadsBottomSide",
      idx:self.drawPadsBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawPadsBottomSide.mObserverExplorer,
      valueExplorer:&self.drawPadsBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadsTopSide",
      idx:self.drawPadsTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawPadsTopSide.mObserverExplorer,
      valueExplorer:&self.drawPadsTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLayoutBottomSide",
      idx:self.drawTextsLayoutBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawTextsLayoutBottomSide.mObserverExplorer,
      valueExplorer:&self.drawTextsLayoutBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLayoutTopSide",
      idx:self.drawTextsLayoutTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawTextsLayoutTopSide.mObserverExplorer,
      valueExplorer:&self.drawTextsLayoutTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLegendBottomSide",
      idx:self.drawTextsLegendBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawTextsLegendBottomSide.mObserverExplorer,
      valueExplorer:&self.drawTextsLegendBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLegendTopSide",
      idx:self.drawTextsLegendTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawTextsLegendTopSide.mObserverExplorer,
      valueExplorer:&self.drawTextsLegendTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTracksBottomSide",
      idx:self.drawTracksBottomSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawTracksBottomSide.mObserverExplorer,
      valueExplorer:&self.drawTracksBottomSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTracksTopSide",
      idx:self.drawTracksTopSide.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawTracksTopSide.mObserverExplorer,
      valueExplorer:&self.drawTracksTopSide.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawVias",
      idx:self.drawVias.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.drawVias.mObserverExplorer,
      valueExplorer:&self.drawVias.mValueExplorer
    )
    createEntryForPropertyNamed (
      "fileExtension",
      idx:self.fileExtension.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.fileExtension.mObserverExplorer,
      valueExplorer:&self.fileExtension.mValueExplorer
    )
    createEntryForPropertyNamed (
      "horizontalMirror",
      idx:self.horizontalMirror.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.horizontalMirror.mObserverExplorer,
      valueExplorer:&self.horizontalMirror.mValueExplorer
    )
    createEntryForPropertyNamed (
      "measurementUnitForPadHoleInPDF",
      idx:self.measurementUnitForPadHoleInPDF.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.measurementUnitForPadHoleInPDF.mObserverExplorer,
      valueExplorer:&self.measurementUnitForPadHoleInPDF.mValueExplorer
    )
    createEntryForPropertyNamed (
      "name",
      idx:self.name.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.name.mObserverExplorer,
      valueExplorer:&self.name.mValueExplorer
    )
    createEntryForPropertyNamed (
      "padHoleDiameterInPDF",
      idx:self.padHoleDiameterInPDF.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.padHoleDiameterInPDF.mObserverExplorer,
      valueExplorer:&self.padHoleDiameterInPDF.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    view.frame = viewFrame
  //--- Set content size
    mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_PMArtworkDocument_mDataSelection.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (mEasyBindingsObjectIndex) + className
    mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    let sw = NSScrollView (frame:frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  func showObjectWindowFromExplorerButton (_ : Any) {
    if mExplorerWindow == nil {
      buildExplorerWindow ()
    }
    mExplorerWindow?.makeKeyAndOrderFront(nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  func deleteSelectionControllerWindowAction (_ : Any) {
    clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton!.target = nil
    mExplorerWindow?.orderOut (nil)
    mExplorerWindow = nil
  }

  //···················································································································*

  private final func bind_property_drawBoardLimits (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawBoardLimits (self.drawBoardLimits)
    self.drawBoardLimits.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawBoardLimits.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawBoardLimits.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawBoardLimits.setProp (inValue)
          }
        }
      }
    }
    self.drawBoardLimits.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawBoardLimits.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesBottomSide (self.drawComponentNamesBottomSide)
    self.drawComponentNamesBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentNamesBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentNamesBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentNamesBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentNamesBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesTopSide (self.drawComponentNamesTopSide)
    self.drawComponentNamesTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentNamesTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentNamesTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentNamesTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentNamesTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesBottomSide (self.drawComponentValuesBottomSide)
    self.drawComponentValuesBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentValuesBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentValuesBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentValuesBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentValuesBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesTopSide (self.drawComponentValuesTopSide)
    self.drawComponentValuesTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentValuesTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentValuesTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentValuesTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentValuesTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendBottomSide (self.drawPackageLegendBottomSide)
    self.drawPackageLegendBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPackageLegendBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPackageLegendBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawPackageLegendBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPackageLegendBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendTopSide (self.drawPackageLegendTopSide)
    self.drawPackageLegendTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPackageLegendTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPackageLegendTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawPackageLegendTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPackageLegendTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadHolesInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadHolesInPDF (self.drawPadHolesInPDF)
    self.drawPadHolesInPDF.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadHolesInPDF.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadHolesInPDF.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadHolesInPDF.setProp (inValue)
          }
        }
      }
    }
    self.drawPadHolesInPDF.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadHolesInPDF.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsBottomSide (self.drawPadsBottomSide)
    self.drawPadsBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadsBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadsBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawPadsBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadsBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsTopSide (self.drawPadsTopSide)
    self.drawPadsTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadsTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadsTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawPadsTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadsTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutBottomSide (self.drawTextsLayoutBottomSide)
    self.drawTextsLayoutBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLayoutBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLayoutBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLayoutBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLayoutBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutTopSide (self.drawTextsLayoutTopSide)
    self.drawTextsLayoutTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLayoutTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLayoutTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLayoutTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLayoutTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendBottomSide (self.drawTextsLegendBottomSide)
    self.drawTextsLegendBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLegendBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLegendBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLegendBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLegendBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendTopSide (self.drawTextsLegendTopSide)
    self.drawTextsLegendTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLegendTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLegendTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLegendTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLegendTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksBottomSide (self.drawTracksBottomSide)
    self.drawTracksBottomSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksBottomSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksBottomSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksBottomSide.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksBottomSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksBottomSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksTopSide (self.drawTracksTopSide)
    self.drawTracksTopSide.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksTopSide.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksTopSide.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksTopSide.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksTopSide.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksTopSide.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawVias (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawVias (self.drawVias)
    self.drawVias.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawVias.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawVias.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawVias.setProp (inValue)
          }
        }
      }
    }
    self.drawVias.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawVias.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_fileExtension (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_fileExtension (self.fileExtension)
    self.fileExtension.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.fileExtension.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.fileExtension.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.fileExtension.setProp (inValue)
          }
        }
      }
    }
    self.fileExtension.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.fileExtension.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_horizontalMirror (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_horizontalMirror (self.horizontalMirror)
    self.horizontalMirror.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.horizontalMirror.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.horizontalMirror.writeModelFunction = { (inValue : Bool) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.horizontalMirror.setProp (inValue)
          }
        }
      }
    }
    self.horizontalMirror.validateAndWriteModelFunction = { (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.horizontalMirror.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_measurementUnitForPadHoleInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_measurementUnitForPadHoleInPDF (self.measurementUnitForPadHoleInPDF)
    self.measurementUnitForPadHoleInPDF.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.measurementUnitForPadHoleInPDF.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.measurementUnitForPadHoleInPDF.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.measurementUnitForPadHoleInPDF.setProp (inValue)
          }
        }
      }
    }
    self.measurementUnitForPadHoleInPDF.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.measurementUnitForPadHoleInPDF.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_name (self.name)
    self.name.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.name.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.name.setProp (inValue)
          }
        }
      }
    }
    self.name.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.name.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padHoleDiameterInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_padHoleDiameterInPDF (self.padHoleDiameterInPDF)
    self.padHoleDiameterInPDF.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padHoleDiameterInPDF.prop {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.padHoleDiameterInPDF.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.padHoleDiameterInPDF.setProp (inValue)
          }
        }
      }
    }
    self.padHoleDiameterInPDF.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.padHoleDiameterInPDF.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }



  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
  //--- drawBoardLimits
    self.drawBoardLimits.readModelFunction = nil 
    self.drawBoardLimits.writeModelFunction = nil 
    self.drawBoardLimits.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawBoardLimits (self.drawBoardLimits)
  //--- drawComponentNamesBottomSide
    self.drawComponentNamesBottomSide.readModelFunction = nil 
    self.drawComponentNamesBottomSide.writeModelFunction = nil 
    self.drawComponentNamesBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentNamesBottomSide (self.drawComponentNamesBottomSide)
  //--- drawComponentNamesTopSide
    self.drawComponentNamesTopSide.readModelFunction = nil 
    self.drawComponentNamesTopSide.writeModelFunction = nil 
    self.drawComponentNamesTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentNamesTopSide (self.drawComponentNamesTopSide)
  //--- drawComponentValuesBottomSide
    self.drawComponentValuesBottomSide.readModelFunction = nil 
    self.drawComponentValuesBottomSide.writeModelFunction = nil 
    self.drawComponentValuesBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentValuesBottomSide (self.drawComponentValuesBottomSide)
  //--- drawComponentValuesTopSide
    self.drawComponentValuesTopSide.readModelFunction = nil 
    self.drawComponentValuesTopSide.writeModelFunction = nil 
    self.drawComponentValuesTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawComponentValuesTopSide (self.drawComponentValuesTopSide)
  //--- drawPackageLegendBottomSide
    self.drawPackageLegendBottomSide.readModelFunction = nil 
    self.drawPackageLegendBottomSide.writeModelFunction = nil 
    self.drawPackageLegendBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPackageLegendBottomSide (self.drawPackageLegendBottomSide)
  //--- drawPackageLegendTopSide
    self.drawPackageLegendTopSide.readModelFunction = nil 
    self.drawPackageLegendTopSide.writeModelFunction = nil 
    self.drawPackageLegendTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPackageLegendTopSide (self.drawPackageLegendTopSide)
  //--- drawPadHolesInPDF
    self.drawPadHolesInPDF.readModelFunction = nil 
    self.drawPadHolesInPDF.writeModelFunction = nil 
    self.drawPadHolesInPDF.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPadHolesInPDF (self.drawPadHolesInPDF)
  //--- drawPadsBottomSide
    self.drawPadsBottomSide.readModelFunction = nil 
    self.drawPadsBottomSide.writeModelFunction = nil 
    self.drawPadsBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPadsBottomSide (self.drawPadsBottomSide)
  //--- drawPadsTopSide
    self.drawPadsTopSide.readModelFunction = nil 
    self.drawPadsTopSide.writeModelFunction = nil 
    self.drawPadsTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawPadsTopSide (self.drawPadsTopSide)
  //--- drawTextsLayoutBottomSide
    self.drawTextsLayoutBottomSide.readModelFunction = nil 
    self.drawTextsLayoutBottomSide.writeModelFunction = nil 
    self.drawTextsLayoutBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLayoutBottomSide (self.drawTextsLayoutBottomSide)
  //--- drawTextsLayoutTopSide
    self.drawTextsLayoutTopSide.readModelFunction = nil 
    self.drawTextsLayoutTopSide.writeModelFunction = nil 
    self.drawTextsLayoutTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLayoutTopSide (self.drawTextsLayoutTopSide)
  //--- drawTextsLegendBottomSide
    self.drawTextsLegendBottomSide.readModelFunction = nil 
    self.drawTextsLegendBottomSide.writeModelFunction = nil 
    self.drawTextsLegendBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLegendBottomSide (self.drawTextsLegendBottomSide)
  //--- drawTextsLegendTopSide
    self.drawTextsLegendTopSide.readModelFunction = nil 
    self.drawTextsLegendTopSide.writeModelFunction = nil 
    self.drawTextsLegendTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTextsLegendTopSide (self.drawTextsLegendTopSide)
  //--- drawTracksBottomSide
    self.drawTracksBottomSide.readModelFunction = nil 
    self.drawTracksBottomSide.writeModelFunction = nil 
    self.drawTracksBottomSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTracksBottomSide (self.drawTracksBottomSide)
  //--- drawTracksTopSide
    self.drawTracksTopSide.readModelFunction = nil 
    self.drawTracksTopSide.writeModelFunction = nil 
    self.drawTracksTopSide.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawTracksTopSide (self.drawTracksTopSide)
  //--- drawVias
    self.drawVias.readModelFunction = nil 
    self.drawVias.writeModelFunction = nil 
    self.drawVias.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_drawVias (self.drawVias)
  //--- fileExtension
    self.fileExtension.readModelFunction = nil 
    self.fileExtension.writeModelFunction = nil 
    self.fileExtension.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_fileExtension (self.fileExtension)
  //--- horizontalMirror
    self.horizontalMirror.readModelFunction = nil 
    self.horizontalMirror.writeModelFunction = nil 
    self.horizontalMirror.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_horizontalMirror (self.horizontalMirror)
  //--- measurementUnitForPadHoleInPDF
    self.measurementUnitForPadHoleInPDF.readModelFunction = nil 
    self.measurementUnitForPadHoleInPDF.writeModelFunction = nil 
    self.measurementUnitForPadHoleInPDF.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_measurementUnitForPadHoleInPDF (self.measurementUnitForPadHoleInPDF)
  //--- name
    self.name.readModelFunction = nil 
    self.name.writeModelFunction = nil 
    self.name.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_name (self.name)
  //--- padHoleDiameterInPDF
    self.padHoleDiameterInPDF.readModelFunction = nil 
    self.padHoleDiameterInPDF.writeModelFunction = nil 
    self.padHoleDiameterInPDF.validateAndWriteModelFunction = nil 
    mModel?.removeEBObserverOf_padHoleDiameterInPDF (self.padHoleDiameterInPDF)
  //---
    mModel = nil    
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

