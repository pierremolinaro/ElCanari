//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS REGENERATED BY EASY BINDINGS, ONLY MODIFY IT WITHIN USER ZONES
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

//--- START OF USER ZONE 1

private func computeRasnet (_ inPointArray : [CanariPoint], _ ioBezierPath : inout EBBezierPath) {
  if inPointArray.count >= 2 {
    var points = inPointArray
  //------------------------------- Find the two nearest points
    var firstPointIndex = 0
    var secondPointIndex = 1
    var d = CanariPoint.squareOfCanariDistance (points [0], points [1])
    for j in 0 ..< points.count {
      for k in j+1 ..< points.count {
       let dd = CanariPoint.squareOfCanariDistance (points [j], points [k])
        if dd < d {
          d = dd
          firstPointIndex = j
          secondPointIndex = k
        }
      }
    }
  //------------------------------- Enter first segment
    ioBezierPath.move (to: points [firstPointIndex].cocoaPoint)
    ioBezierPath.line (to: points [secondPointIndex].cocoaPoint)
  //------------------------------- Transfer handled points in dedicaced array
    var handledPoints = [points [firstPointIndex], points [secondPointIndex]]
    points.remove (at: secondPointIndex) // SecondPoint first, its index is > than first point index
    points.remove (at: firstPointIndex)
  //------------------------------- Loop on remaining points
    while points.count > 0 {
      firstPointIndex = 0
      secondPointIndex = 0
      d = CanariPoint.squareOfCanariDistance (handledPoints [0], points [0])
      for i in 0 ..< handledPoints.count {
        let p1 = handledPoints [i]
        for j in 0 ..< points.count {
          let p2 = points [j]
          let dd = CanariPoint.squareOfCanariDistance (p1, p2)
          if dd < d {
            firstPointIndex = i
            secondPointIndex = j
            d = dd
          }
        }
      }
    //--- Enter segment
      ioBezierPath.move (to: handledPoints [firstPointIndex].cocoaPoint)
      ioBezierPath.line (to: points [secondPointIndex].cocoaPoint)
    //--- Transfer found point in handled point array
      handledPoints.append (points [secondPointIndex])
      points.remove (at: secondPointIndex)
    }
  }
}

//--- END OF USER ZONE 1

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func transient_ProjectRoot_rastnetShape (
       _ self_mBoardObjects_netNameAndPadLocation : [BoardObject_netNameAndPadLocation]
) -> EBShape {
//--- START OF USER ZONE 2
      //--- Build net dictionary
        var dictionary = [String : [CanariPoint]] ()
        for optionalArray in self_mBoardObjects_netNameAndPadLocation {
          if let array = optionalArray.netNameAndPadLocation {
            for p in array {
              let netName = p.netName
              let location = p.location
              dictionary [netName] = (dictionary [netName] ?? []) + [location]
            }
          }
        }
        var bp = EBBezierPath ()
        bp.lineWidth = 1.0
        bp.lineJoinStyle = .round
        bp.lineCapStyle = .round
        for (_, locationArray) in dictionary {
          computeRasnet (locationArray, &bp)
        }
        return EBShape (stroke: [bp], .yellow)
//--- END OF USER ZONE 2
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
