//--- START OF USER ZONE 1


//--- END OF USER ZONE 1
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func compute_FontRootEntity_sampleStringBezierPath (_ self_2E_characters_0 : [FontCharacterEntity_segmentArrayForDrawing],
                                                    _ self_2E_characters_1 : [FontCharacterEntity_advance],
                                                    _ g_5F_Preferences_21__2E_sampleString_2 : String,
                                                    _ g_5F_Preferences_21__2E_sampleStringSize_3 : Double) -> CGPath {
//--- START OF USER ZONE 2
  func toCocoa (_ value : Int) -> CGFloat {
    return CGFloat (value) * CGFloat (g_5F_Preferences_21__2E_sampleStringSize_3) / 14.0
  }

//  let sampleStringASUnicodeArray : [UInt32] = g_5F_Preferences_21__2E_sampleString_2.unicodeScalars.map { $0.value }
  let sampleStringAsMacRomanData = g_5F_Preferences_21__2E_sampleString_2.data (using: .macOSRoman, allowLossyConversion: true)!
  var currentX : CGFloat = 0.0
  let path = CGMutablePath ()
  for unicodeCharacter in sampleStringAsMacRomanData { // sampleStringASUnicodeArray {
    let characterIndex = Int (unicodeCharacter) - 32
//    if characterIndex > (0x7F - 32) {
//      characterIndex -= 32
//    }
    if characterIndex < self_2E_characters_0.count {
      let segmentArrayDescriptor : FontCharacterEntity_segmentArrayForDrawing = self_2E_characters_0 [characterIndex]
      switch segmentArrayDescriptor.segmentArrayForDrawing.prop {
      case .noSelection, .multipleSelection :
        break
      case .singleSelection (let segmentArray) :
        for segment in segmentArray.code {
          path.move    (to: CGPoint (x: currentX + toCocoa (segment.x1), y: toCocoa (segment.y1)))
          path.addLine (to: CGPoint (x: currentX + toCocoa (segment.x2), y: toCocoa (segment.y2)))
        }
      }
    }
    if characterIndex < self_2E_characters_1.count {
      currentX += toCocoa (self_2E_characters_1 [characterIndex].advance.propval)
    }
  }
  return path
//--- END OF USER ZONE 2
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
