//----------------------------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//----------------------------------------------------------------------------------------------------------------------

import Cocoa

//----------------------------------------------------------------------------------------------------------------------
//   EBTransientValueProperty <T>
//----------------------------------------------------------------------------------------------------------------------

extension EBTransientValueProperty {

  //····················································································································

  func defineTransientDependancy1 <T1> (_ in1 : EBReadOnlyValueProperty <T1>,
                                        _ computationCallBack : @escaping (_ in1 : T1) -> T) {
    in1.addEBObserver (self)
    self.mReadModelFunction = { [weak in1] in
      if let uw1 = in1 {
        switch uw1.selection {
        case .single (let v1) :
          let v = computationCallBack (v1)
          return .single (v)
        default:
          return .empty
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

  func defineTransientDependancy2 <T1, T2> (_ in1 : EBReadOnlyValueProperty <T1>,
                                            _ in2 : EBReadOnlyValueProperty <T2>,
                                            _ computationCallBack : @escaping (_ in1 : T1, _ in2 : T2) -> T) {
    in1.addEBObserver (self)
    in2.addEBObserver (self)
    self.mReadModelFunction = { [weak in1, weak in2] in
      if let uw1 = in1, let uw2 = in2 {
        switch (uw1.selection, uw2.selection) {
        case (.single (let v1), .single (let v2)) :
          let v = computationCallBack (v1, v2)
          return .single (v)
        default:
          return .empty
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

  func defineTransientDependancy3 <T1, T2, T3> (_ in1 : EBReadOnlyValueProperty <T1>,
                                                _ in2 : EBReadOnlyValueProperty <T2>,
                                                _ in3 : EBReadOnlyValueProperty <T3>,
                                                _ computationCallBack : @escaping (_ in1 : T1, _ in2 : T2, _ in3 : T3) -> T) {
    in1.addEBObserver (self)
    in2.addEBObserver (self)
    in3.addEBObserver (self)
    self.mReadModelFunction = { [weak in1, weak in2, weak in3] in
      if let uw1 = in1, let uw2 = in2, let uw3 = in3 {
        switch (uw1.selection, uw2.selection, uw3.selection) {
        case (.single (let v1), .single (let v2), .single (let v3)) :
          let v = computationCallBack (v1, v2, v3)
          return .single (v)
        default:
          return .empty
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

  func defineTransientDependancy4 <T1, T2, T3, T4> (_ in1 : EBReadOnlyValueProperty <T1>,
                                                _ in2 : EBReadOnlyValueProperty <T2>,
                                                _ in3 : EBReadOnlyValueProperty <T3>,
                                                _ in4 : EBReadOnlyValueProperty <T4>,
                                                _ computationCallBack : @escaping (_ in1 : T1, _ in2 : T2, _ in3 : T3, _ in4 : T4) -> T) {
    in1.addEBObserver (self)
    in2.addEBObserver (self)
    in3.addEBObserver (self)
    in4.addEBObserver (self)
    self.mReadModelFunction = { [weak in1, weak in2, weak in3, weak in4] in
      if let uw1 = in1, let uw2 = in2, let uw3 = in3 , let uw4 = in4 {
        switch (uw1.selection, uw2.selection, uw3.selection, uw4.selection) {
        case (.single (let v1), .single (let v2), .single (let v3), .single (let v4)) :
          let v = computationCallBack (v1, v2, v3, v4)
          return .single (v)
        default:
          return .empty
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

  func defineTransientDependancy5 <T1, T2, T3, T4, T5> (
        _ in1 : EBReadOnlyValueProperty <T1>,
        _ in2 : EBReadOnlyValueProperty <T2>,
        _ in3 : EBReadOnlyValueProperty <T3>,
        _ in4 : EBReadOnlyValueProperty <T4>,
        _ in5 : EBReadOnlyValueProperty <T5>,
        _ computationCallBack : @escaping (_ in1 : T1, _ in2 : T2, _ in3 : T3, _ in4 : T4, _ in5 : T5) -> T) {
    in1.addEBObserver (self)
    in2.addEBObserver (self)
    in3.addEBObserver (self)
    in4.addEBObserver (self)
    in5.addEBObserver (self)
    self.mReadModelFunction = { [weak in1, weak in2, weak in3, weak in4, weak in5] in
      if let uw1 = in1, let uw2 = in2, let uw3 = in3, let uw4 = in4, let uw5 = in5 {
        switch (uw1.selection, uw2.selection, uw3.selection, uw4.selection, uw5.selection) {
        case (.single (let v1), .single (let v2), .single (let v3), .single (let v4), .single (let v5)) :
          let v = computationCallBack (v1, v2, v3, v4, v5)
          return .single (v)
        default:
          return .empty
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

}

//----------------------------------------------------------------------------------------------------------------------
