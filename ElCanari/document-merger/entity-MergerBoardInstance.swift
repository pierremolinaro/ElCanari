//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_x : class {
  var x : Int { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_y : class {
  var y : Int { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_instanceRotation : class {
  var instanceRotation : QuadrantRotation { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_instanceRect : class {
  var instanceRect : CanariRect? { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_modelName : class {
  var modelName : String? { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_boardLimitWidth : class {
  var boardLimitWidth : Int? { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_selectionDisplay : class {
  var selectionDisplay : EBShape? { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol MergerBoardInstance_objectDisplay : class {
  var objectDisplay : EBShape? { get }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Entity: MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class MergerBoardInstance : EBGraphicManagedObject,
         MergerBoardInstance_x,
         MergerBoardInstance_y,
         MergerBoardInstance_instanceRotation,
         MergerBoardInstance_instanceRect,
         MergerBoardInstance_modelName,
         MergerBoardInstance_boardLimitWidth,
         MergerBoardInstance_selectionDisplay,
         MergerBoardInstance_objectDisplay {

  //····················································································································
  //   Atomic property: x
  //····················································································································

  let x_property = EBStoredProperty_Int (defaultValue: 0)

  //····················································································································

  var x : Int {
    get { return self.x_property.propval }
    set { self.x_property.setProp (newValue) }
  }

  //····················································································································

  var x_property_selection : EBSelection <Int> { return self.x_property.prop }

  //····················································································································
  //   Atomic property: y
  //····················································································································

  let y_property = EBStoredProperty_Int (defaultValue: 0)

  //····················································································································

  var y : Int {
    get { return self.y_property.propval }
    set { self.y_property.setProp (newValue) }
  }

  //····················································································································

  var y_property_selection : EBSelection <Int> { return self.y_property.prop }

  //····················································································································
  //   Atomic property: instanceRotation
  //····················································································································

  let instanceRotation_property = EBStoredProperty_QuadrantRotation (defaultValue: QuadrantRotation.rotation0)

  //····················································································································

  var instanceRotation : QuadrantRotation {
    get { return self.instanceRotation_property.propval }
    set { self.instanceRotation_property.setProp (newValue) }
  }

  //····················································································································

  var instanceRotation_property_selection : EBSelection <QuadrantRotation> { return self.instanceRotation_property.prop }

  //····················································································································
  //   To one property: myModel
  //····················································································································

    #if NEWTOONE
     let myModel_property = StoredObject_BoardModel ()
    #else
      let myModel_property = ToOneRelationship_MergerBoardInstance_myModel ()
    #endif

  //····················································································································

  var myModel_property_selection : EBSelection <BoardModel?> {
    return .single (self.myModel_property.propval)
  }

  //····················································································································

  var myModel : BoardModel? {
    get { return self.myModel_property.propval }
    set { self.myModel_property.setProp (newValue) }
  }

  //····················································································································

    #if NEWTOONE
      var myModel_none : StoredObject_BoardModel { return self.myModel_property }
    #else
      var myModel_none : ToOneRelationship_MergerBoardInstance_myModel { return self.myModel_property }
    #endif

  //····················································································································

  var myModel_none_selection : EBSelection <Bool> {
    return .single (self.myModel_property.propval == nil)
  }

  //····················································································································
  //   Transient property: instanceRect
  //····················································································································

  let instanceRect_property = EBTransientProperty_CanariRect ()

  //····················································································································

  var instanceRect_property_selection : EBSelection <CanariRect> {
    return self.instanceRect_property.prop
  }

  //····················································································································

  var instanceRect : CanariRect? {
    switch self.instanceRect_property_selection {
    case .empty, .multiple :
      return nil
    case .single (let v) :
      return v
    }
  }

  //····················································································································
  //   Transient property: modelName
  //····················································································································

  let modelName_property = EBTransientProperty_String ()

  //····················································································································

  var modelName_property_selection : EBSelection <String> {
    return self.modelName_property.prop
  }

  //····················································································································

  var modelName : String? {
    switch self.modelName_property_selection {
    case .empty, .multiple :
      return nil
    case .single (let v) :
      return v
    }
  }

  //····················································································································
  //   Transient property: boardLimitWidth
  //····················································································································

  let boardLimitWidth_property = EBTransientProperty_Int ()

  //····················································································································

  var boardLimitWidth_property_selection : EBSelection <Int> {
    return self.boardLimitWidth_property.prop
  }

  //····················································································································

  var boardLimitWidth : Int? {
    switch self.boardLimitWidth_property_selection {
    case .empty, .multiple :
      return nil
    case .single (let v) :
      return v
    }
  }

  //····················································································································
  //   To one property: myRoot
  //····················································································································

    #if NEWTOONE
     let myRoot_property = StoredObject_MergerRoot ()
    #else
      let myRoot_property = ToOneRelationship_MergerBoardInstance_myRoot ()
    #endif

  //····················································································································

  var myRoot_property_selection : EBSelection <MergerRoot?> {
    return .single (self.myRoot_property.propval)
  }

  //····················································································································

  var myRoot : MergerRoot? {
    get { return self.myRoot_property.propval }
    set { self.myRoot_property.setProp (newValue) }
  }

  //····················································································································

    #if NEWTOONE
      var myRoot_none : StoredObject_MergerRoot { return self.myRoot_property }
    #else
      var myRoot_none : ToOneRelationship_MergerBoardInstance_myRoot { return self.myRoot_property }
    #endif

  //····················································································································

  var myRoot_none_selection : EBSelection <Bool> {
    return .single (self.myRoot_property.propval == nil)
  }

  //····················································································································
  //    init
  //····················································································································

  required init (_ ebUndoManager : EBUndoManager?) {
    super.init (ebUndoManager)
  //--- Atomic property: x
    self.x_property.ebUndoManager = self.ebUndoManager
  //--- Atomic property: y
    self.y_property.ebUndoManager = self.ebUndoManager
  //--- Atomic property: instanceRotation
    self.instanceRotation_property.ebUndoManager = self.ebUndoManager
  //--- To one property: myModel (has opposite to many relationship: myInstances) §
    #if !NEWTOONE
      self.myModel_property.owner = self
    #else
      self.myModel_property.ebUndoManager = self.ebUndoManager
    #endif
  //--- Atomic property: instanceRect
    self.instanceRect_property.mReadModelFunction = { [weak self] in
      if let unwSelf = self {
        var kind = unwSelf.x_property_selection.kind ()
        kind &= unwSelf.y_property_selection.kind ()
        kind &= unwSelf.myModel_property.modelWidth_property_selection.kind ()
        kind &= unwSelf.myModel_property.modelHeight_property_selection.kind ()
        kind &= unwSelf.instanceRotation_property_selection.kind ()
        switch kind {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single :
          switch (unwSelf.x_property_selection, unwSelf.y_property_selection, unwSelf.myModel_property.modelWidth_property_selection, unwSelf.myModel_property.modelHeight_property_selection, unwSelf.instanceRotation_property_selection) {
          case (.single (let v0), .single (let v1), .single (let v2), .single (let v3), .single (let v4)) :
            return .single (transient_MergerBoardInstance_instanceRect (v0, v1, v2, v3, v4))
          default :
            return .empty
          }
        }
      }else{
        return .empty
      }
    }
    self.x_property.addEBObserver (self.instanceRect_property)
    self.y_property.addEBObserver (self.instanceRect_property)
    self.myModel_property.addEBObserverOf_modelWidth (self.instanceRect_property)
    self.myModel_property.addEBObserverOf_modelHeight (self.instanceRect_property)
    self.instanceRotation_property.addEBObserver (self.instanceRect_property)
  //--- Atomic property: modelName
    self.modelName_property.mReadModelFunction = { [weak self] in
      if let unwSelf = self {
        let kind = unwSelf.myModel_property.name_property_selection.kind ()
        switch kind {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single :
          switch (unwSelf.myModel_property.name_property_selection) {
          case (.single (let v0)) :
            return .single (transient_MergerBoardInstance_modelName (v0))
          default :
            return .empty
          }
        }
      }else{
        return .empty
      }
    }
    self.myModel_property.addEBObserverOf_name (self.modelName_property)
  //--- Atomic property: boardLimitWidth
    self.boardLimitWidth_property.mReadModelFunction = { [weak self] in
      if let unwSelf = self {
        let kind = unwSelf.myModel_property.modelLimitWidth_property_selection.kind ()
        switch kind {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single :
          switch (unwSelf.myModel_property.modelLimitWidth_property_selection) {
          case (.single (let v0)) :
            return .single (transient_MergerBoardInstance_boardLimitWidth (v0))
          default :
            return .empty
          }
        }
      }else{
        return .empty
      }
    }
    self.myModel_property.addEBObserverOf_modelLimitWidth (self.boardLimitWidth_property)
  //--- Atomic property: selectionDisplay
    self.selectionDisplay_property.mReadModelFunction = { [weak self] in
      if let unwSelf = self {
        let kind = unwSelf.instanceRect_property_selection.kind ()
        switch kind {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single :
          switch (unwSelf.instanceRect_property_selection) {
          case (.single (let v0)) :
            return .single (transient_MergerBoardInstance_selectionDisplay (v0))
          default :
            return .empty
          }
        }
      }else{
        return .empty
      }
    }
    self.instanceRect_property.addEBObserver (self.selectionDisplay_property)
  //--- Atomic property: objectDisplay
    self.objectDisplay_property.mReadModelFunction = { [weak self] in
      if let unwSelf = self {
        var kind = unwSelf.x_property_selection.kind ()
        kind &= unwSelf.y_property_selection.kind ()
        kind &= unwSelf.myModel_property.modelWidth_property_selection.kind ()
        kind &= unwSelf.myModel_property.modelHeight_property_selection.kind ()
        kind &= unwSelf.instanceRotation_property_selection.kind ()
        kind &= unwSelf.myModel_property.imageForInstances_property_selection.kind ()
        switch kind {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single :
          switch (unwSelf.x_property_selection, unwSelf.y_property_selection, unwSelf.myModel_property.modelWidth_property_selection, unwSelf.myModel_property.modelHeight_property_selection, unwSelf.instanceRotation_property_selection, unwSelf.myModel_property.imageForInstances_property_selection) {
          case (.single (let v0), .single (let v1), .single (let v2), .single (let v3), .single (let v4), .single (let v5)) :
            return .single (transient_MergerBoardInstance_objectDisplay (v0, v1, v2, v3, v4, v5))
          default :
            return .empty
          }
        }
      }else{
        return .empty
      }
    }
    self.x_property.addEBObserver (self.objectDisplay_property)
    self.y_property.addEBObserver (self.objectDisplay_property)
    self.myModel_property.addEBObserverOf_modelWidth (self.objectDisplay_property)
    self.myModel_property.addEBObserverOf_modelHeight (self.objectDisplay_property)
    self.instanceRotation_property.addEBObserver (self.objectDisplay_property)
    self.myModel_property.addEBObserverOf_imageForInstances (self.objectDisplay_property)
  //--- To one property: myRoot (has opposite to many relationship: boardInstances) §
    #if !NEWTOONE
      self.myRoot_property.owner = self
    #else
      self.myRoot_property.ebUndoManager = self.ebUndoManager
    #endif
  //--- Install undoers and opposite setter for relationships
  //--- Register properties for handling signature
  //--- Extern delegates
  }

  //····················································································································

  override internal func removeAllObservers () {
    super.removeAllObservers ()
    self.x_property.removeEBObserver (self.instanceRect_property)
    self.y_property.removeEBObserver (self.instanceRect_property)
    self.myModel_property.removeEBObserverOf_modelWidth (self.instanceRect_property)
    self.myModel_property.removeEBObserverOf_modelHeight (self.instanceRect_property)
    self.instanceRotation_property.removeEBObserver (self.instanceRect_property)
    self.myModel_property.removeEBObserverOf_name (self.modelName_property)
    self.myModel_property.removeEBObserverOf_modelLimitWidth (self.boardLimitWidth_property)
    self.instanceRect_property.removeEBObserver (self.selectionDisplay_property)
    self.x_property.removeEBObserver (self.objectDisplay_property)
    self.y_property.removeEBObserver (self.objectDisplay_property)
    self.myModel_property.removeEBObserverOf_modelWidth (self.objectDisplay_property)
    self.myModel_property.removeEBObserverOf_modelHeight (self.objectDisplay_property)
    self.instanceRotation_property.removeEBObserver (self.objectDisplay_property)
    self.myModel_property.removeEBObserverOf_imageForInstances (self.objectDisplay_property)
  //--- Unregister properties for handling signature
  }

  //····················································································································
  //    Extern delegates
  //····················································································································


  //····················································································································
  //    populateExplorerWindow
  //····················································································································

  override func populateExplorerWindow (_ y : inout CGFloat, view : NSView) {
    super.populateExplorerWindow (&y, view:view)
    createEntryForPropertyNamed (
      "x",
      idx:self.x_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.x_property.mObserverExplorer,
      valueExplorer:&self.x_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "y",
      idx:self.y_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.y_property.mObserverExplorer,
      valueExplorer:&self.y_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "instanceRotation",
      idx:self.instanceRotation_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.instanceRotation_property.mObserverExplorer,
      valueExplorer:&self.instanceRotation_property.mValueExplorer
    )
    createEntryForTitle ("Properties", y:&y, view:view)
    createEntryForPropertyNamed (
      "instanceRect",
      idx:self.instanceRect_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.instanceRect_property.mObserverExplorer,
      valueExplorer:&self.instanceRect_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelName",
      idx:self.modelName_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelName_property.mObserverExplorer,
      valueExplorer:&self.modelName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "boardLimitWidth",
      idx:self.boardLimitWidth_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.boardLimitWidth_property.mObserverExplorer,
      valueExplorer:&self.boardLimitWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "selectionDisplay",
      idx:self.selectionDisplay_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.selectionDisplay_property.mObserverExplorer,
      valueExplorer:&self.selectionDisplay_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "objectDisplay",
      idx:self.objectDisplay_property.ebObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.objectDisplay_property.mObserverExplorer,
      valueExplorer:&self.objectDisplay_property.mValueExplorer
    )
    createEntryForTitle ("Transients", y:&y, view:view)
    createEntryForTitle ("ToMany Relationships", y:&y, view:view)
    createEntryForToOneRelationshipNamed (
      "myModel",
      idx:self.myModel_property.ebObjectIndex,
      y: &y,
      view: view,
      valueExplorer:&self.myModel_property.mValueExplorer
    )
    createEntryForToOneRelationshipNamed (
      "myRoot",
      idx:self.myRoot_property.ebObjectIndex,
      y: &y,
      view: view,
      valueExplorer:&self.myRoot_property.mValueExplorer
    )
    createEntryForTitle ("ToOne Relationships", y:&y, view:view)
  }

  //····················································································································
  //    clearObjectExplorer
  //····················································································································

  override func clearObjectExplorer () {
  //--- Atomic property: x
    self.x_property.mObserverExplorer = nil
    self.x_property.mValueExplorer = nil
  //--- Atomic property: y
    self.y_property.mObserverExplorer = nil
    self.y_property.mValueExplorer = nil
  //--- Atomic property: instanceRotation
    self.instanceRotation_property.mObserverExplorer = nil
    self.instanceRotation_property.mValueExplorer = nil
  //--- To one property: myModel
    self.myModel_property.mObserverExplorer = nil
    self.myModel_property.mValueExplorer = nil
  //--- To one property: myRoot
    self.myRoot_property.mObserverExplorer = nil
    self.myRoot_property.mValueExplorer = nil
  //---
    super.clearObjectExplorer ()
  }

  //····················································································································
  //    cleanUpToManyRelationships
  //····················································································································

  override internal func cleanUpToManyRelationships () {
  //---
    super.cleanUpToManyRelationships ()
  }

  //····················································································································
  //    cleanUpToOneRelationships
  //····················································································································

  override internal func cleanUpToOneRelationships () {
    self.myModel_property.setProp (nil)
    self.myRoot_property.setProp (nil)
  //---
    super.cleanUpToOneRelationships ()
  }

  //····················································································································
  //    saveIntoDictionary
  //····················································································································

  override func saveIntoDictionary (_ ioDictionary : NSMutableDictionary) {
    super.saveIntoDictionary (ioDictionary)
  //--- Atomic property: x
    self.x_property.storeIn (dictionary: ioDictionary, forKey:"x")
  //--- Atomic property: y
    self.y_property.storeIn (dictionary: ioDictionary, forKey:"y")
  //--- Atomic property: instanceRotation
    self.instanceRotation_property.storeIn (dictionary: ioDictionary, forKey:"instanceRotation")
  }

  //····················································································································
  //    setUpWithDictionary
  //····················································································································

  override func setUpWithDictionary (_ inDictionary : NSDictionary,
                                     managedObjectArray : inout [EBManagedObject]) {
    super.setUpWithDictionary (inDictionary, managedObjectArray:&managedObjectArray)
  //--- To one property: myModel
    do{
      let possibleEntity = readEntityFromDictionary (
        inRelationshipName: "myModel",
        inDictionary: inDictionary,
        managedObjectArray: &managedObjectArray
      )
      if let entity = possibleEntity as? BoardModel {
        self.myModel_property.setProp (entity)
      }
    }
  //--- To one property: myRoot
    do{
      let possibleEntity = readEntityFromDictionary (
        inRelationshipName: "myRoot",
        inDictionary: inDictionary,
        managedObjectArray: &managedObjectArray
      )
      if let entity = possibleEntity as? MergerRoot {
        self.myRoot_property.setProp (entity)
      }
    }
  }

  //····················································································································
  //    setUpAtomicPropertiesWithDictionary
  //····················································································································

  override func setUpAtomicPropertiesWithDictionary (_ inDictionary : NSDictionary) {
    super.setUpAtomicPropertiesWithDictionary (inDictionary)
  //--- Atomic property: x
    self.x_property.readFrom (dictionary: inDictionary, forKey:"x")
  //--- Atomic property: y
    self.y_property.readFrom (dictionary: inDictionary, forKey:"y")
  //--- Atomic property: instanceRotation
    self.instanceRotation_property.readFrom (dictionary: inDictionary, forKey:"instanceRotation")
  }

  //····················································································································
  //   accessibleObjects
  //····················································································································

  override func accessibleObjects (objects : inout [EBManagedObject]) {
    super.accessibleObjects (objects: &objects)
  //--- To one property: myModel
    if let managedObject = self.myModel_property.propval {
      objects.append (managedObject)
    }
  //--- To one property: myRoot
    if let managedObject = self.myRoot_property.propval {
      objects.append (managedObject)
    }
  }

  //····················································································································
  //   accessibleObjectsForSaveOperation
  //····················································································································

  override func accessibleObjectsForSaveOperation (objects : inout [EBManagedObject]) {
    super.accessibleObjectsForSaveOperation (objects: &objects)
  //--- To one property: myModel
    if let managedObject = self.myModel_property.propval {
      objects.append (managedObject)
    }
  //--- To one property: myRoot
    if let managedObject = self.myRoot_property.propval {
      objects.append (managedObject)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyArrayOf_MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyArrayOf_MergerBoardInstance : ReadOnlyAbstractArrayProperty <MergerBoardInstance> {

  //····················································································································

  internal override func updateObservers (removedSet inRemovedSet : Set <MergerBoardInstance>, addedSet inAddedSet : Set <MergerBoardInstance>) {
    super.updateObservers (removedSet: inRemovedSet, addedSet: inAddedSet)
  //--- Remove observers from removed objects
    self.removeEBObserversOf_x_fromElementsOfSet (inRemovedSet) // Stored property
    self.removeEBObserversOf_y_fromElementsOfSet (inRemovedSet) // Stored property
    self.removeEBObserversOf_instanceRotation_fromElementsOfSet (inRemovedSet) // Stored property
    self.removeEBObserversOf_instanceRect_fromElementsOfSet (inRemovedSet) // Transient property
    self.removeEBObserversOf_modelName_fromElementsOfSet (inRemovedSet) // Transient property
    self.removeEBObserversOf_boardLimitWidth_fromElementsOfSet (inRemovedSet) // Transient property
    self.removeEBObserversOf_selectionDisplay_fromElementsOfSet (inRemovedSet) // Transient property
    self.removeEBObserversOf_objectDisplay_fromElementsOfSet (inRemovedSet) // Transient property
  //--- Add observers to added objects
    self.addEBObserversOf_x_toElementsOfSet (inAddedSet) // Stored property
    self.addEBObserversOf_y_toElementsOfSet (inAddedSet) // Stored property
    self.addEBObserversOf_instanceRotation_toElementsOfSet (inAddedSet) // Stored property
    self.addEBObserversOf_instanceRect_toElementsOfSet (inAddedSet) // Transient property
    self.addEBObserversOf_modelName_toElementsOfSet (inAddedSet) // Transient property
    self.addEBObserversOf_boardLimitWidth_toElementsOfSet (inAddedSet) // Transient property
    self.addEBObserversOf_selectionDisplay_toElementsOfSet (inAddedSet) // Transient property
    self.addEBObserversOf_objectDisplay_toElementsOfSet (inAddedSet) // Transient property
  }

  //····················································································································
  //   Observers of 'x' stored property
  //····················································································································

  private var mObserversOf_x = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_x (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_x.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.x_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_x (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_x.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.x_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_x_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_x.apply { (_ observer : EBEvent) in
        managedObject.x_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_x_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    self.mObserversOf_x.apply { (_ observer : EBEvent) in
      observer.postEvent ()
      for managedObject in inSet {
        managedObject.x_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'y' stored property
  //····················································································································

  private var mObserversOf_y = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_y (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_y.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.y_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_y (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_y.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.y_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_y_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_y.apply { (_ observer : EBEvent) in
        managedObject.y_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_y_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    self.mObserversOf_y.apply { (_ observer : EBEvent) in
      observer.postEvent ()
      for managedObject in inSet {
        managedObject.y_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'instanceRotation' stored property
  //····················································································································

  private var mObserversOf_instanceRotation = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_instanceRotation (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_instanceRotation.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.instanceRotation_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_instanceRotation (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_instanceRotation.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.instanceRotation_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_instanceRotation_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_instanceRotation.apply { (_ observer : EBEvent) in
        managedObject.instanceRotation_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_instanceRotation_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    self.mObserversOf_instanceRotation.apply { (_ observer : EBEvent) in
      observer.postEvent ()
      for managedObject in inSet {
        managedObject.instanceRotation_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'instanceRect' transient property
  //····················································································································

  private var mObserversOf_instanceRect = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_instanceRect (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_instanceRect.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.instanceRect_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_instanceRect (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_instanceRect.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.instanceRect_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_instanceRect_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_instanceRect.apply { (_ observer : EBEvent) in
        managedObject.instanceRect_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_instanceRect_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_instanceRect.apply { (_ observer : EBEvent) in
        managedObject.instanceRect_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'modelName' transient property
  //····················································································································

  private var mObserversOf_modelName = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_modelName (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_modelName.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.modelName_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelName (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_modelName.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.modelName_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_modelName_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_modelName.apply { (_ observer : EBEvent) in
        managedObject.modelName_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_modelName_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_modelName.apply { (_ observer : EBEvent) in
        managedObject.modelName_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'boardLimitWidth' transient property
  //····················································································································

  private var mObserversOf_boardLimitWidth = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_boardLimitWidth (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_boardLimitWidth.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.boardLimitWidth_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardLimitWidth (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_boardLimitWidth.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.boardLimitWidth_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_boardLimitWidth_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_boardLimitWidth.apply { (_ observer : EBEvent) in
        managedObject.boardLimitWidth_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_boardLimitWidth_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_boardLimitWidth.apply { (_ observer : EBEvent) in
        managedObject.boardLimitWidth_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'selectionDisplay' transient property
  //····················································································································

  private var mObserversOf_selectionDisplay = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_selectionDisplay (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_selectionDisplay.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.selectionDisplay_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_selectionDisplay (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_selectionDisplay.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.selectionDisplay_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_selectionDisplay_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_selectionDisplay.apply { (_ observer : EBEvent) in
        managedObject.selectionDisplay_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_selectionDisplay_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_selectionDisplay.apply { (_ observer : EBEvent) in
        managedObject.selectionDisplay_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'objectDisplay' transient property
  //····················································································································

  private var mObserversOf_objectDisplay = EBWeakEventSet ()

  //····················································································································

  final func addEBObserverOf_objectDisplay (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_objectDisplay.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.objectDisplay_property.addEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func removeEBObserverOf_objectDisplay (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_objectDisplay.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.objectDisplay_property.removeEBObserver (inObserver)
      }
    }
  }

  //····················································································································

  final func addEBObserversOf_objectDisplay_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_objectDisplay.apply { (_ observer : EBEvent) in
        managedObject.objectDisplay_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_objectDisplay_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_objectDisplay.apply { (_ observer : EBEvent) in
        managedObject.objectDisplay_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    TransientArrayOf MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class TransientArrayOf_MergerBoardInstance : ReadOnlyArrayOf_MergerBoardInstance {

  //····················································································································
  //   Data provider
  //····················································································································

  private var mDataProvider : ReadOnlyArrayOf_MergerBoardInstance? = nil
  private var mTransientKind : PropertyKind = .empty

  //····················································································································

  func setDataProvider (_ inProvider : ReadOnlyArrayOf_MergerBoardInstance?) {
    if self.mDataProvider !== inProvider {
      self.mDataProvider?.detachClient (self)
      self.mDataProvider = inProvider
      self.mDataProvider?.attachClient (self)
    }
  }

  //····················································································································

  override func notifyModelDidChange () {
    let newArray : [MergerBoardInstance] 
    if let dataProvider = self.mDataProvider {
      switch dataProvider.prop {
      case .empty :
        newArray = []
        self.mTransientKind = .empty
      case .single (let v) :
        newArray = v
        self.mTransientKind = .single
       case .multiple :
        newArray = []
        self.mTransientKind = .multiple
      }
    }else{
      newArray = []
      self.mTransientKind = .empty
    }
    self.mInternalArrayValue = newArray
    super.notifyModelDidChange ()
  }

  //····················································································································

  override var prop : EBSelection < [MergerBoardInstance] > {
    switch self.mTransientKind {
    case .empty :
      return .empty
    case .single :
      return .single (self.mInternalArrayValue)
    case .multiple :
      return .multiple
    }
  }

  //····················································································································

  override var propval : [MergerBoardInstance] { return self.mInternalArrayValue }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    TransientArrayOfSuperOf MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class TransientArrayOfSuperOf_MergerBoardInstance <SUPER : EBManagedObject> : ReadOnlyArrayOf_MergerBoardInstance {

  //····················································································································
  //   Data provider
  //····················································································································

  private var mDataProvider : ReadOnlyAbstractArrayProperty <SUPER>? = nil
  private var mTransientKind : PropertyKind = .empty

  //····················································································································

  func setDataProvider (_ inProvider : ReadOnlyAbstractArrayProperty <SUPER>?) {
    if self.mDataProvider !== inProvider {
      self.mDataProvider?.detachClient (self)
      self.mDataProvider = inProvider
      self.mDataProvider?.attachClient (self)
    }
  }

  //····················································································································

  override func notifyModelDidChange () {
    var newModelArray : [SUPER] 
    if let dataProvider = self.mDataProvider {
      switch dataProvider.prop {
      case .empty :
        newModelArray = []
        self.mTransientKind = .empty
      case .single (let v) :
        newModelArray = v
        self.mTransientKind = .single
       case .multiple :
        newModelArray = []
        self.mTransientKind = .multiple
      }
    }else{
      newModelArray = []
      self.mTransientKind = .empty
    }
    var newArray = [MergerBoardInstance] ()
    for superObject in newModelArray {
      if let object = superObject as? MergerBoardInstance {
        newArray.append (object)
      }
    }
    self.mInternalArrayValue = newArray
    super.notifyModelDidChange ()
  }

  //····················································································································

  override var prop : EBSelection < [MergerBoardInstance] > {
    switch self.mTransientKind {
    case .empty :
      return .empty
    case .single :
      return .single (self.mInternalArrayValue)
    case .multiple :
      return .multiple
    }
  }

  //····················································································································

  override var propval : [MergerBoardInstance] { return self.mInternalArrayValue }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    To many relationship read write: MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadWriteArrayOf_MergerBoardInstance : ReadOnlyArrayOf_MergerBoardInstance {

  //····················································································································
 
  func setProp (_ value :  [MergerBoardInstance]) { } // Abstract method
  
  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Proxy: ProxyArrayOf_MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class ProxyArrayOf_MergerBoardInstance : ReadWriteArrayOf_MergerBoardInstance {

  //····················································································································

  private var mModel : ReadWriteArrayOf_MergerBoardInstance? = nil

  //····················································································································

  func setModel (_ inModel : ReadWriteArrayOf_MergerBoardInstance?) {
    if self.mModel !== inModel {
      self.mModel?.detachClient (self)
      self.mModel = inModel
      self.mModel?.attachClient (self)
    }
  }

  //····················································································································

  override func notifyModelDidChange () {
    let newModelArray : [MergerBoardInstance]
    if let model = self.mModel {
      switch model.prop {
      case .empty :
        newModelArray = []
      case .single (let v) :
        newModelArray = v
       case .multiple :
        newModelArray = []
      }
    }else{
      newModelArray = []
    }
    self.mInternalArrayValue = newModelArray
    super.notifyModelDidChange ()
  }

  //····················································································································

  override func setProp (_ inArrayValue : [MergerBoardInstance]) {
    self.mModel?.setProp (inArrayValue)
  }

  //····················································································································

  override var prop : EBSelection < [MergerBoardInstance] > {
    if let model = self.mModel {
      return model.prop
    }else{
      return .empty
    }
  }

  //····················································································································

  override var propval : [MergerBoardInstance] {
    if let model = self.mModel {
      switch model.prop {
      case .empty, .multiple :
        return []
      case .single (let v) :
        return v
      }
    }else{
      return []
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    To many relationship: MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class StoredArrayOf_MergerBoardInstance : ReadWriteArrayOf_MergerBoardInstance, EBSignatureObserverProtocol {

  //····················································································································
  //   Opposite relationship management
  //····················································································································

  private var mSetOppositeRelationship : Optional < (_ inManagedObject : MergerBoardInstance) -> Void > = nil
  private var mResetOppositeRelationship : Optional < (_ inManagedObject : MergerBoardInstance) -> Void > = nil

  //····················································································································

  func setOppositeRelationShipFunctions (setter inSetter : @escaping (_ inManagedObject : MergerBoardInstance) -> Void,
                                         resetter inResetter : @escaping (_ inManagedObject : MergerBoardInstance) -> Void) {
    self.mSetOppositeRelationship = inSetter
    self.mResetOppositeRelationship = inResetter
  }
  
  //····················································································································

  private var mPrefKey : String? = nil

  //····················································································································

  var mValueExplorer : NSPopUpButton? {
    didSet {
      if let unwrappedExplorer = self.mValueExplorer {
        switch prop {
        case .empty, .multiple :
          break ;
        case .single (let v) :
          updateManagedObjectToManyRelationshipDisplay (objectArray: v, popUpButton: unwrappedExplorer)
        }
      }
    }
  }

  //····················································································································
  //  Init
  //····················································································································

  convenience init (prefKey : String) {
    self.init ()
    self.mPrefKey = prefKey
    if let array = UserDefaults.standard.array (forKey: prefKey) as? [NSDictionary] {
      var objectArray = [MergerBoardInstance] ()
      for dictionary in array {
        if let object = newInstanceOfEntityNamed (self.ebUndoManager, "MergerBoardInstance") as? MergerBoardInstance {
          object.setUpAtomicPropertiesWithDictionary (dictionary)
          objectArray.append (object)
        }
      }
      self.setProp (objectArray)
    }
  }

  //····················································································································
  // Model will change 
  //····················································································································

  override func notifyModelDidChangeFrom (oldValue inOldValue : [MergerBoardInstance]) {
  //--- Register old value in undo manager
    self.ebUndoManager?.registerUndo (withTarget: self, selector:#selector(performUndo(_:)), object: inOldValue)
  //---
    super.notifyModelDidChangeFrom (oldValue: inOldValue)
  }
 
  //····················································································································

  @objc func performUndo (_ oldValue : [MergerBoardInstance]) {
    self.mInternalArrayValue = oldValue
  }
 
  //····················································································································
  // Model did change 
  //····················································································································

  override func notifyModelDidChange () {
  //--- Update explorer
    if let valueExplorer = self.mValueExplorer {
      updateManagedObjectToManyRelationshipDisplay (objectArray: self.mInternalArrayValue, popUpButton: valueExplorer)
    }
  //--- Notify observers
    self.postEvent ()
    self.clearSignatureCache ()
  //--- Write in preferences ?
    self.writeInPreferences ()
  //---
    super.notifyModelDidChange ()
  }

  //····················································································································
  // Update observers 
  //····················································································································

  internal override func updateObservers (removedSet inRemovedSet : Set <MergerBoardInstance>, addedSet inAddedSet : Set <MergerBoardInstance>) {
    super.updateObservers (removedSet: inRemovedSet, addedSet: inAddedSet)
  //---
    for managedObject in inRemovedSet {
      managedObject.setSignatureObserver (observer: nil)
      self.mResetOppositeRelationship? (managedObject)
    }
  //---
    for managedObject in inAddedSet {
      managedObject.setSignatureObserver (observer: self)
      self.mSetOppositeRelationship? (managedObject)
    }
  }
 
  //····················································································································

  override var prop : EBSelection < [MergerBoardInstance] > { return .single (self.mInternalArrayValue) }

  //····················································································································

  override func setProp (_ inValue : [MergerBoardInstance]) { self.mInternalArrayValue = inValue }

  //····················································································································

  override var propval : [MergerBoardInstance] { return self.mInternalArrayValue }

  //····················································································································

  private func writeInPreferences () {
    if let prefKey = self.mPrefKey {
      var dictionaryArray = [NSDictionary] ()
      for object in self.mInternalArrayValue {
        let d = NSMutableDictionary ()
        object.saveIntoDictionary (d)
        d [ENTITY_KEY] = nil // Remove entity key, not used in preferences
        dictionaryArray.append (d)
      }
      UserDefaults.standard.set (dictionaryArray, forKey: prefKey)
    }
  }

  //····················································································································

  func remove (_ object : MergerBoardInstance) {
    if let idx = self.mInternalArrayValue.firstIndex (of: object) {
      self.mInternalArrayValue.remove (at: idx)
    }
  }
  
  //····················································································································

  func add (_ object : MergerBoardInstance) {
    if !self.internalSetValue.contains (object) {
      self.mInternalArrayValue.append (object)
    }
  }
  
  //····················································································································
  //   signature
  //····················································································································

  private weak var mSignatureObserver : EBSignatureObserverProtocol? = nil // SOULD BE WEAK

  //····················································································································

  private var mSignatureCache : UInt32? = nil

  //····················································································································

  final func setSignatureObserver (observer : EBSignatureObserverProtocol?) {
    self.mSignatureObserver = observer
    for object in self.mInternalArrayValue {
      object.setSignatureObserver (observer: observer)
    }
  }

  //····················································································································

  final func signature () -> UInt32 {
    let computedSignature : UInt32
    if let s = self.mSignatureCache {
      computedSignature = s
    }else{
      computedSignature = computeSignature ()
      self.mSignatureCache = computedSignature
    }
    return computedSignature
  }
  
  //····················································································································

  final func computeSignature () -> UInt32 {
    var crc : UInt32 = 0
    for object in self.mInternalArrayValue {
      crc.accumulateUInt32 (object.signature ())
    }
    return crc
  }

  //····················································································································

  final func clearSignatureCache () {
    if self.mSignatureCache != nil {
      self.mSignatureCache = nil
      self.mSignatureObserver?.clearSignatureCache ()
    }
  }

  //····················································································································
 
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyObject_MergerBoardInstance 
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyObject_MergerBoardInstance : ReadOnlyAbstractObjectProperty <MergerBoardInstance> {

  //····················································································································

  internal override func notifyModelDidChangeFrom (oldValue inOldValue : MergerBoardInstance?) {
    super.notifyModelDidChangeFrom (oldValue: inOldValue)
  //--- Remove observers from removed objects
    inOldValue?.x_property.removeEBObserversFrom (&self.mObserversOf_x) // Stored property
    inOldValue?.y_property.removeEBObserversFrom (&self.mObserversOf_y) // Stored property
    inOldValue?.instanceRotation_property.removeEBObserversFrom (&self.mObserversOf_instanceRotation) // Stored property
    inOldValue?.instanceRect_property.removeEBObserversFrom (&self.mObserversOf_instanceRect) // Transient property
    inOldValue?.modelName_property.removeEBObserversFrom (&self.mObserversOf_modelName) // Transient property
    inOldValue?.boardLimitWidth_property.removeEBObserversFrom (&self.mObserversOf_boardLimitWidth) // Transient property
    inOldValue?.selectionDisplay_property.removeEBObserversFrom (&self.mObserversOf_selectionDisplay) // Transient property
    inOldValue?.objectDisplay_property.removeEBObserversFrom (&self.mObserversOf_objectDisplay) // Transient property
  //--- Add observers to added objects
    self.mInternalValue?.x_property.addEBObserversFrom (&self.mObserversOf_x) // Stored property
    self.mInternalValue?.y_property.addEBObserversFrom (&self.mObserversOf_y) // Stored property
    self.mInternalValue?.instanceRotation_property.addEBObserversFrom (&self.mObserversOf_instanceRotation) // Stored property
    self.mInternalValue?.instanceRect_property.addEBObserversFrom (&self.mObserversOf_instanceRect) // Transient property
    self.mInternalValue?.modelName_property.addEBObserversFrom (&self.mObserversOf_modelName) // Transient property
    self.mInternalValue?.boardLimitWidth_property.addEBObserversFrom (&self.mObserversOf_boardLimitWidth) // Transient property
    self.mInternalValue?.selectionDisplay_property.addEBObserversFrom (&self.mObserversOf_selectionDisplay) // Transient property
    self.mInternalValue?.objectDisplay_property.addEBObserversFrom (&self.mObserversOf_objectDisplay) // Transient property
  }

  //····················································································································
  //   Observers of 'x' stored property
  //····················································································································

  private var mObserversOf_x = EBWeakEventSet ()

  //····················································································································

  var x_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.x_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_x (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_x.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
       v?.x_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_x (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_x.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.x_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_x_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_x.apply { (_ observer : EBEvent) in
        managedObject.x_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_x_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    self.mObserversOf_x.apply { (_ observer : EBEvent) in
      observer.postEvent ()
      for managedObject in inSet {
        managedObject.x_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'y' stored property
  //····················································································································

  private var mObserversOf_y = EBWeakEventSet ()

  //····················································································································

  var y_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.y_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_y (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_y.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
       v?.y_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_y (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_y.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.y_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_y_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_y.apply { (_ observer : EBEvent) in
        managedObject.y_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_y_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    self.mObserversOf_y.apply { (_ observer : EBEvent) in
      observer.postEvent ()
      for managedObject in inSet {
        managedObject.y_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'instanceRotation' stored property
  //····················································································································

  private var mObserversOf_instanceRotation = EBWeakEventSet ()

  //····················································································································

  var instanceRotation_property_selection : EBSelection <QuadrantRotation?> {
    if let model = self.propval {
      switch (model.instanceRotation_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_instanceRotation (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_instanceRotation.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
       v?.instanceRotation_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_instanceRotation (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_instanceRotation.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.instanceRotation_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_instanceRotation_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_instanceRotation.apply { (_ observer : EBEvent) in
        managedObject.instanceRotation_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_instanceRotation_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    self.mObserversOf_instanceRotation.apply { (_ observer : EBEvent) in
      observer.postEvent ()
      for managedObject in inSet {
        managedObject.instanceRotation_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'instanceRect' transient property
  //····················································································································

  private var mObserversOf_instanceRect = EBWeakEventSet ()

  //····················································································································

  var instanceRect_property_selection : EBSelection <CanariRect?> {
    if let model = self.propval {
      switch (model.instanceRect_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_instanceRect (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_instanceRect.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.instanceRect_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_instanceRect (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_instanceRect.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.instanceRect_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_instanceRect_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_instanceRect.apply { (_ observer : EBEvent) in
        managedObject.instanceRect_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_instanceRect_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_instanceRect.apply { (_ observer : EBEvent) in
        managedObject.instanceRect_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'modelName' transient property
  //····················································································································

  private var mObserversOf_modelName = EBWeakEventSet ()

  //····················································································································

  var modelName_property_selection : EBSelection <String?> {
    if let model = self.propval {
      switch (model.modelName_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelName (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_modelName.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.modelName_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelName (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_modelName.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.modelName_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_modelName_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_modelName.apply { (_ observer : EBEvent) in
        managedObject.modelName_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_modelName_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_modelName.apply { (_ observer : EBEvent) in
        managedObject.modelName_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'boardLimitWidth' transient property
  //····················································································································

  private var mObserversOf_boardLimitWidth = EBWeakEventSet ()

  //····················································································································

  var boardLimitWidth_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardLimitWidth_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardLimitWidth (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_boardLimitWidth.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.boardLimitWidth_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardLimitWidth (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_boardLimitWidth.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.boardLimitWidth_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_boardLimitWidth_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_boardLimitWidth.apply { (_ observer : EBEvent) in
        managedObject.boardLimitWidth_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_boardLimitWidth_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_boardLimitWidth.apply { (_ observer : EBEvent) in
        managedObject.boardLimitWidth_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'selectionDisplay' transient property
  //····················································································································

  private var mObserversOf_selectionDisplay = EBWeakEventSet ()

  //····················································································································

  var selectionDisplay_property_selection : EBSelection <EBShape?> {
    if let model = self.propval {
      switch (model.selectionDisplay_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_selectionDisplay (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_selectionDisplay.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.selectionDisplay_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_selectionDisplay (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_selectionDisplay.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.selectionDisplay_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_selectionDisplay_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_selectionDisplay.apply { (_ observer : EBEvent) in
        managedObject.selectionDisplay_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_selectionDisplay_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_selectionDisplay.apply { (_ observer : EBEvent) in
        managedObject.selectionDisplay_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································
  //   Observers of 'objectDisplay' transient property
  //····················································································································

  private var mObserversOf_objectDisplay = EBWeakEventSet ()

  //····················································································································

  var objectDisplay_property_selection : EBSelection <EBShape?> {
    if let model = self.propval {
      switch (model.objectDisplay_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_objectDisplay (_ inObserver : EBEvent) {
    self.addEBObserver (inObserver)
    self.mObserversOf_objectDisplay.insert (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.objectDisplay_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_objectDisplay (_ inObserver : EBEvent) {
    self.removeEBObserver (inObserver)
    self.mObserversOf_objectDisplay.remove (inObserver)
    switch prop {
    case .empty, .multiple :
      break
    case .single (let v) :
      v?.objectDisplay_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

  final func addEBObserversOf_objectDisplay_toElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_objectDisplay.apply { (_ observer : EBEvent) in
        managedObject.objectDisplay_property.addEBObserver (observer)
      }
    }
  }

  //····················································································································

  final func removeEBObserversOf_objectDisplay_fromElementsOfSet (_ inSet : Set<MergerBoardInstance>) {
    for managedObject in inSet {
      self.mObserversOf_objectDisplay.apply { (_ observer : EBEvent) in
        managedObject.objectDisplay_property.removeEBObserver (observer)
      }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    TransientObject MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class TransientObject_MergerBoardInstance : ReadOnlyObject_MergerBoardInstance {

  //····················································································································
  //   Data provider
  //····················································································································

  private var mDataProvider : ReadOnlyObject_MergerBoardInstance? = nil
  private var mTransientKind : PropertyKind = .empty

  //····················································································································

  func setDataProvider (_ inProvider : ReadOnlyObject_MergerBoardInstance?) {
    if self.mDataProvider !== inProvider {
      self.mDataProvider?.detachClient (self)
      self.mDataProvider = inProvider
      self.mDataProvider?.attachClient (self)
    }
  }

  //····················································································································

  override func notifyModelDidChange () {
    let newObject : MergerBoardInstance? 
    if let dataProvider = self.mDataProvider {
      switch dataProvider.prop {
      case .empty :
        newObject = nil
        self.mTransientKind = .empty
      case .single (let v) :
        newObject = v
        self.mTransientKind = .single
       case .multiple :
        newObject = nil
        self.mTransientKind = .empty
      }
    }else{
      newObject = nil
      self.mTransientKind = .empty
    }
    self.mInternalValue = newObject
    super.notifyModelDidChange ()
  }

  //····················································································································

  override var prop : EBSelection < MergerBoardInstance? > {
    switch self.mTransientKind {
    case .empty :
      return .empty
    case .single :
      if let internalValue = self.mInternalValue {
        return .single (internalValue)
      }else{
        return .empty
      }
    case .multiple :
      return .multiple
    }
  }

  //····················································································································

  override var propval : MergerBoardInstance? { return self.mInternalValue }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadWriteObject_MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadWriteObject_MergerBoardInstance : ReadOnlyObject_MergerBoardInstance {

  //····················································································································
 
  func setProp (_ inValue : MergerBoardInstance?) { } // Abstract method
  
  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Proxy: ProxyObject_MergerBoardInstance
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class ProxyObject_MergerBoardInstance : ReadWriteObject_MergerBoardInstance {

  //····················································································································

  private var mModel : ReadWriteObject_MergerBoardInstance? = nil

  //····················································································································

  func setModel (_ inModel : ReadWriteObject_MergerBoardInstance?) {
    if self.mModel !== inModel {
      self.mModel?.detachClient (self)
      self.mModel = inModel
      self.mModel?.attachClient (self)
    }
  }

  //····················································································································

  override func notifyModelDidChange () {
    let newModel : MergerBoardInstance?
    if let model = self.mModel {
      switch model.prop {
      case .empty :
        newModel = nil
      case .single (let v) :
        newModel = v
       case .multiple :
        newModel = nil
      }
    }else{
      newModel = nil
    }
    self.mInternalValue = newModel
    super.notifyModelDidChange ()
  }

  //····················································································································

  override func setProp (_ inValue : MergerBoardInstance?) {
    self.mModel?.setProp (inValue)
  }

  //····················································································································

  override var prop : EBSelection < MergerBoardInstance? > {
    if let model = self.mModel {
      return model.prop
    }else{
      return .empty
    }
  }

  //····················································································································

  override var propval : MergerBoardInstance? {
    if let model = self.mModel {
      switch model.prop {
      case .empty, .multiple :
        return nil
      case .single (let v) :
        return v
      }
    }else{
      return nil
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    StoredObject_MergerBoardInstance 
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class StoredObject_MergerBoardInstance : ReadWriteObject_MergerBoardInstance, EBSignatureObserverProtocol {

  //····················································································································
  //   Opposite relationship management
  //····················································································································

  private var mSetOppositeRelationship : Optional < (_ inManagedObject : MergerBoardInstance) -> Void > = nil
  private var mResetOppositeRelationship : Optional < (_ inManagedObject : MergerBoardInstance) -> Void > = nil

  //····················································································································

  func setOppositeRelationShipFunctions (setter inSetter : @escaping (_ inManagedObject : MergerBoardInstance) -> Void,
                                         resetter inResetter : @escaping (_ inManagedObject : MergerBoardInstance) -> Void) {
    self.mSetOppositeRelationship = inSetter
    self.mResetOppositeRelationship = inResetter
  }
  
  //····················································································································

  var mValueExplorer : NSButton? {
    didSet {
      if let unwrappedExplorer = self.mValueExplorer {
        switch self.prop {
        case .empty, .multiple :
          break ;
        case .single (let v) :
          updateManagedObjectToOneRelationshipDisplay (object: v, button: unwrappedExplorer)
        }
      }
    }
  }

 //····················································································································
  // Model will change 
  //····················································································································

  override func notifyModelDidChangeFrom (oldValue inOldValue : MergerBoardInstance?) {
  //--- Register old value in undo manager
    self.ebUndoManager?.registerUndo (withTarget: self, selector:#selector(performUndo(_:)), object: inOldValue)
  //---
    if let object = inOldValue {
      object.setSignatureObserver (observer: nil)
      self.mResetOppositeRelationship? (object)
    }
  //---
    if let object = self.mInternalValue {
      object.setSignatureObserver (observer: self)
      self.mSetOppositeRelationship? (object)
    }
  //---
    super.notifyModelDidChangeFrom (oldValue: inOldValue)
  }
 
  //····················································································································

  @objc func performUndo (_ oldValue : MergerBoardInstance?) {
    self.mInternalValue = oldValue
  }
 
  //····················································································································
  // Model did change 
  //····················································································································

  override func notifyModelDidChange () {
  //--- Update explorer
    if let valueExplorer = self.mValueExplorer {
      updateManagedObjectToOneRelationshipDisplay (object: self.mInternalValue, button: valueExplorer)
    }
  //--- Notify observers
    self.postEvent ()
    self.clearSignatureCache ()
  //---
    super.notifyModelDidChange ()
  }

  //····················································································································

  override var prop : EBSelection < MergerBoardInstance? > {
    if let object = self.mInternalValue {
      return .single (object)
    }else{
      return .empty
    }
  }

  //····················································································································

  override func setProp (_ inValue : MergerBoardInstance?) { self.mInternalValue = inValue }

  //····················································································································

  override var propval : MergerBoardInstance? { return self.mInternalValue }

  //····················································································································

  func remove (_ object : MergerBoardInstance) {
    if object === self.mInternalValue {
      self.mInternalValue = nil
    }
  }
  
  //····················································································································

  func add (_ object : MergerBoardInstance) {
    if object !== self.mInternalValue {
      self.mInternalValue = object
    }
  }
  
  //····················································································································
  //   signature
  //····················································································································

  private weak var mSignatureObserver : EBSignatureObserverProtocol? = nil // SOULD BE WEAK

  //····················································································································

  private var mSignatureCache : UInt32? = nil

  //····················································································································

  final func setSignatureObserver (observer : EBSignatureObserverProtocol?) {
    self.mSignatureObserver = observer
    self.mInternalValue?.setSignatureObserver (observer: observer)
  }

  //····················································································································

  final func signature () -> UInt32 {
    let computedSignature : UInt32
    if let s = self.mSignatureCache {
      computedSignature = s
    }else{
      computedSignature = computeSignature ()
      self.mSignatureCache = computedSignature
    }
    return computedSignature
  }
  
  //····················································································································

  final func computeSignature () -> UInt32 {
    var crc : UInt32 = 0
    if let object = self.mInternalValue {
      crc.accumulateUInt32 (object.signature ())
    }
    return crc
  }

  //····················································································································

  final func clearSignatureCache () {
    if self.mSignatureCache != nil {
      self.mSignatureCache = nil
      self.mSignatureObserver?.clearSignatureCache ()
    }
  }

  //····················································································································
 
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    To one relationship: myModel
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#if !NEWTOONE
final class ToOneRelationship_MergerBoardInstance_myModel : EBAbstractProperty {

  //····················································································································
  //   Value explorer
  //····················································································································

  var mValueExplorer : NSButton? {
    didSet {
      if let unwrappedExplorer = self.mValueExplorer {
        switch prop {
        case .empty, .multiple :
          break ;
        case .single (let v) :
          updateManagedObjectToOneRelationshipDisplay (object: v, button:unwrappedExplorer)
        }
      }
    }
  }

  //····················································································································

  weak var owner : MergerBoardInstance? { // SOULD BE WEAK
    didSet {
      if let unwrappedExplorer = self.mValueExplorer {
        updateManagedObjectToOneRelationshipDisplay (object: propval, button: unwrappedExplorer)
      }
    }
  }
 
  //····················································································································

  private var mValue : BoardModel? {
    didSet {
      if let unwrappedOwner = self.owner, oldValue !== self.mValue {
      //--- Register old value in undo manager
        unwrappedOwner.ebUndoManager?.registerUndo (withTarget:self, selector:#selector(performUndo(_:)), object:oldValue)
      //--- Update explorer
        if let unwrappedExplorer = self.mValueExplorer {
          updateManagedObjectToOneRelationshipDisplay (object: self.mValue, button: unwrappedExplorer)
        }
      //--- Reset old opposite relation ship
        oldValue?.myInstances_property.remove (unwrappedOwner)
      //--- Set new opposite relation ship
        self.mValue?.myInstances_property.add (unwrappedOwner)
      //--- Remove property observers of old object
        oldValue?.artworkName_property.removeEBObserversFrom (&self.mObserversOf_artworkName)
        oldValue?.backComponentNameSegments_property.removeEBObserversFrom (&self.mObserversOf_backComponentNameSegments)
        oldValue?.backComponentNames_property.removeEBObserversFrom (&self.mObserversOf_backComponentNames)
        oldValue?.backComponentNamesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backComponentNamesBezierPaths)
        oldValue?.backComponentValueSegments_property.removeEBObserversFrom (&self.mObserversOf_backComponentValueSegments)
        oldValue?.backComponentValues_property.removeEBObserversFrom (&self.mObserversOf_backComponentValues)
        oldValue?.backComponentValuesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backComponentValuesBezierPaths)
        oldValue?.backLayoutTexts_property.removeEBObserversFrom (&self.mObserversOf_backLayoutTexts)
        oldValue?.backLayoutTextsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backLayoutTextsBezierPaths)
        oldValue?.backLayoutTextsSegments_property.removeEBObserversFrom (&self.mObserversOf_backLayoutTextsSegments)
        oldValue?.backLegendLines_property.removeEBObserversFrom (&self.mObserversOf_backLegendLines)
        oldValue?.backLegendLinesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backLegendLinesBezierPaths)
        oldValue?.backLegendLinesSegments_property.removeEBObserversFrom (&self.mObserversOf_backLegendLinesSegments)
        oldValue?.backLegendTexts_property.removeEBObserversFrom (&self.mObserversOf_backLegendTexts)
        oldValue?.backLegendTextsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backLegendTextsBezierPaths)
        oldValue?.backLegendTextsSegments_property.removeEBObserversFrom (&self.mObserversOf_backLegendTextsSegments)
        oldValue?.backPackages_property.removeEBObserversFrom (&self.mObserversOf_backPackages)
        oldValue?.backPackagesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backPackagesBezierPaths)
        oldValue?.backPackagesSegments_property.removeEBObserversFrom (&self.mObserversOf_backPackagesSegments)
        oldValue?.backPadArray_property.removeEBObserversFrom (&self.mObserversOf_backPadArray)
        oldValue?.backPads_property.removeEBObserversFrom (&self.mObserversOf_backPads)
        oldValue?.backPadsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backPadsBezierPaths)
        oldValue?.backTrackSegments_property.removeEBObserversFrom (&self.mObserversOf_backTrackSegments)
        oldValue?.backTracks_property.removeEBObserversFrom (&self.mObserversOf_backTracks)
        oldValue?.backTracksBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_backTracksBezierPaths)
        oldValue?.boardLimits_property.removeEBObserversFrom (&self.mObserversOf_boardLimits)
        oldValue?.boardLimitsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_boardLimitsBezierPaths)
        oldValue?.drillSegments_property.removeEBObserversFrom (&self.mObserversOf_drillSegments)
        oldValue?.drills_property.removeEBObserversFrom (&self.mObserversOf_drills)
        oldValue?.frontComponentNameSegments_property.removeEBObserversFrom (&self.mObserversOf_frontComponentNameSegments)
        oldValue?.frontComponentNames_property.removeEBObserversFrom (&self.mObserversOf_frontComponentNames)
        oldValue?.frontComponentNamesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontComponentNamesBezierPaths)
        oldValue?.frontComponentValueSegments_property.removeEBObserversFrom (&self.mObserversOf_frontComponentValueSegments)
        oldValue?.frontComponentValues_property.removeEBObserversFrom (&self.mObserversOf_frontComponentValues)
        oldValue?.frontComponentValuesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontComponentValuesBezierPaths)
        oldValue?.frontLayoutTexts_property.removeEBObserversFrom (&self.mObserversOf_frontLayoutTexts)
        oldValue?.frontLayoutTextsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontLayoutTextsBezierPaths)
        oldValue?.frontLayoutTextsSegments_property.removeEBObserversFrom (&self.mObserversOf_frontLayoutTextsSegments)
        oldValue?.frontLegendLines_property.removeEBObserversFrom (&self.mObserversOf_frontLegendLines)
        oldValue?.frontLegendLinesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontLegendLinesBezierPaths)
        oldValue?.frontLegendLinesSegments_property.removeEBObserversFrom (&self.mObserversOf_frontLegendLinesSegments)
        oldValue?.frontLegendTexts_property.removeEBObserversFrom (&self.mObserversOf_frontLegendTexts)
        oldValue?.frontLegendTextsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontLegendTextsBezierPaths)
        oldValue?.frontLegendTextsSegments_property.removeEBObserversFrom (&self.mObserversOf_frontLegendTextsSegments)
        oldValue?.frontPackages_property.removeEBObserversFrom (&self.mObserversOf_frontPackages)
        oldValue?.frontPackagesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontPackagesBezierPaths)
        oldValue?.frontPackagesSegments_property.removeEBObserversFrom (&self.mObserversOf_frontPackagesSegments)
        oldValue?.frontPadArray_property.removeEBObserversFrom (&self.mObserversOf_frontPadArray)
        oldValue?.frontPads_property.removeEBObserversFrom (&self.mObserversOf_frontPads)
        oldValue?.frontPadsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontPadsBezierPaths)
        oldValue?.frontTrackSegments_property.removeEBObserversFrom (&self.mObserversOf_frontTrackSegments)
        oldValue?.frontTracks_property.removeEBObserversFrom (&self.mObserversOf_frontTracks)
        oldValue?.frontTracksBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_frontTracksBezierPaths)
        oldValue?.holesBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_holesBezierPaths)
        oldValue?.imageForInstances_property.removeEBObserversFrom (&self.mObserversOf_imageForInstances)
        oldValue?.imageForModel_property.removeEBObserversFrom (&self.mObserversOf_imageForModel)
        oldValue?.instanceCount_property.removeEBObserversFrom (&self.mObserversOf_instanceCount)
        oldValue?.internalBoardsLimits_property.removeEBObserversFrom (&self.mObserversOf_internalBoardsLimits)
        oldValue?.internalBoardsLimitsBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_internalBoardsLimitsBezierPaths)
        oldValue?.internalBoardsLimitsSegments_property.removeEBObserversFrom (&self.mObserversOf_internalBoardsLimitsSegments)
        oldValue?.modelHeight_property.removeEBObserversFrom (&self.mObserversOf_modelHeight)
        oldValue?.modelHeightUnit_property.removeEBObserversFrom (&self.mObserversOf_modelHeightUnit)
        oldValue?.modelLimitWidth_property.removeEBObserversFrom (&self.mObserversOf_modelLimitWidth)
        oldValue?.modelLimitWidthUnit_property.removeEBObserversFrom (&self.mObserversOf_modelLimitWidthUnit)
        oldValue?.modelWidth_property.removeEBObserversFrom (&self.mObserversOf_modelWidth)
        oldValue?.modelWidthUnit_property.removeEBObserversFrom (&self.mObserversOf_modelWidthUnit)
        oldValue?.myInstances_property.removeEBObserversFrom (&self.mObserversOf_myInstances)
        oldValue?.name_property.removeEBObserversFrom (&self.mObserversOf_name)
        oldValue?.viaShapes_property.removeEBObserversFrom (&self.mObserversOf_viaShapes)
        oldValue?.vias_property.removeEBObserversFrom (&self.mObserversOf_vias)
        oldValue?.viasBezierPaths_property.removeEBObserversFrom (&self.mObserversOf_viasBezierPaths)
        oldValue?.zoom_property.removeEBObserversFrom (&self.mObserversOf_zoom)
      //--- Add property observers to new object
        self.mValue?.artworkName_property.addEBObserversFrom (&self.mObserversOf_artworkName)
        self.mValue?.backComponentNameSegments_property.addEBObserversFrom (&self.mObserversOf_backComponentNameSegments)
        self.mValue?.backComponentNames_property.addEBObserversFrom (&self.mObserversOf_backComponentNames)
        self.mValue?.backComponentNamesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backComponentNamesBezierPaths)
        self.mValue?.backComponentValueSegments_property.addEBObserversFrom (&self.mObserversOf_backComponentValueSegments)
        self.mValue?.backComponentValues_property.addEBObserversFrom (&self.mObserversOf_backComponentValues)
        self.mValue?.backComponentValuesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backComponentValuesBezierPaths)
        self.mValue?.backLayoutTexts_property.addEBObserversFrom (&self.mObserversOf_backLayoutTexts)
        self.mValue?.backLayoutTextsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backLayoutTextsBezierPaths)
        self.mValue?.backLayoutTextsSegments_property.addEBObserversFrom (&self.mObserversOf_backLayoutTextsSegments)
        self.mValue?.backLegendLines_property.addEBObserversFrom (&self.mObserversOf_backLegendLines)
        self.mValue?.backLegendLinesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backLegendLinesBezierPaths)
        self.mValue?.backLegendLinesSegments_property.addEBObserversFrom (&self.mObserversOf_backLegendLinesSegments)
        self.mValue?.backLegendTexts_property.addEBObserversFrom (&self.mObserversOf_backLegendTexts)
        self.mValue?.backLegendTextsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backLegendTextsBezierPaths)
        self.mValue?.backLegendTextsSegments_property.addEBObserversFrom (&self.mObserversOf_backLegendTextsSegments)
        self.mValue?.backPackages_property.addEBObserversFrom (&self.mObserversOf_backPackages)
        self.mValue?.backPackagesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backPackagesBezierPaths)
        self.mValue?.backPackagesSegments_property.addEBObserversFrom (&self.mObserversOf_backPackagesSegments)
        self.mValue?.backPadArray_property.addEBObserversFrom (&self.mObserversOf_backPadArray)
        self.mValue?.backPads_property.addEBObserversFrom (&self.mObserversOf_backPads)
        self.mValue?.backPadsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backPadsBezierPaths)
        self.mValue?.backTrackSegments_property.addEBObserversFrom (&self.mObserversOf_backTrackSegments)
        self.mValue?.backTracks_property.addEBObserversFrom (&self.mObserversOf_backTracks)
        self.mValue?.backTracksBezierPaths_property.addEBObserversFrom (&self.mObserversOf_backTracksBezierPaths)
        self.mValue?.boardLimits_property.addEBObserversFrom (&self.mObserversOf_boardLimits)
        self.mValue?.boardLimitsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_boardLimitsBezierPaths)
        self.mValue?.drillSegments_property.addEBObserversFrom (&self.mObserversOf_drillSegments)
        self.mValue?.drills_property.addEBObserversFrom (&self.mObserversOf_drills)
        self.mValue?.frontComponentNameSegments_property.addEBObserversFrom (&self.mObserversOf_frontComponentNameSegments)
        self.mValue?.frontComponentNames_property.addEBObserversFrom (&self.mObserversOf_frontComponentNames)
        self.mValue?.frontComponentNamesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontComponentNamesBezierPaths)
        self.mValue?.frontComponentValueSegments_property.addEBObserversFrom (&self.mObserversOf_frontComponentValueSegments)
        self.mValue?.frontComponentValues_property.addEBObserversFrom (&self.mObserversOf_frontComponentValues)
        self.mValue?.frontComponentValuesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontComponentValuesBezierPaths)
        self.mValue?.frontLayoutTexts_property.addEBObserversFrom (&self.mObserversOf_frontLayoutTexts)
        self.mValue?.frontLayoutTextsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontLayoutTextsBezierPaths)
        self.mValue?.frontLayoutTextsSegments_property.addEBObserversFrom (&self.mObserversOf_frontLayoutTextsSegments)
        self.mValue?.frontLegendLines_property.addEBObserversFrom (&self.mObserversOf_frontLegendLines)
        self.mValue?.frontLegendLinesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontLegendLinesBezierPaths)
        self.mValue?.frontLegendLinesSegments_property.addEBObserversFrom (&self.mObserversOf_frontLegendLinesSegments)
        self.mValue?.frontLegendTexts_property.addEBObserversFrom (&self.mObserversOf_frontLegendTexts)
        self.mValue?.frontLegendTextsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontLegendTextsBezierPaths)
        self.mValue?.frontLegendTextsSegments_property.addEBObserversFrom (&self.mObserversOf_frontLegendTextsSegments)
        self.mValue?.frontPackages_property.addEBObserversFrom (&self.mObserversOf_frontPackages)
        self.mValue?.frontPackagesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontPackagesBezierPaths)
        self.mValue?.frontPackagesSegments_property.addEBObserversFrom (&self.mObserversOf_frontPackagesSegments)
        self.mValue?.frontPadArray_property.addEBObserversFrom (&self.mObserversOf_frontPadArray)
        self.mValue?.frontPads_property.addEBObserversFrom (&self.mObserversOf_frontPads)
        self.mValue?.frontPadsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontPadsBezierPaths)
        self.mValue?.frontTrackSegments_property.addEBObserversFrom (&self.mObserversOf_frontTrackSegments)
        self.mValue?.frontTracks_property.addEBObserversFrom (&self.mObserversOf_frontTracks)
        self.mValue?.frontTracksBezierPaths_property.addEBObserversFrom (&self.mObserversOf_frontTracksBezierPaths)
        self.mValue?.holesBezierPaths_property.addEBObserversFrom (&self.mObserversOf_holesBezierPaths)
        self.mValue?.imageForInstances_property.addEBObserversFrom (&self.mObserversOf_imageForInstances)
        self.mValue?.imageForModel_property.addEBObserversFrom (&self.mObserversOf_imageForModel)
        self.mValue?.instanceCount_property.addEBObserversFrom (&self.mObserversOf_instanceCount)
        self.mValue?.internalBoardsLimits_property.addEBObserversFrom (&self.mObserversOf_internalBoardsLimits)
        self.mValue?.internalBoardsLimitsBezierPaths_property.addEBObserversFrom (&self.mObserversOf_internalBoardsLimitsBezierPaths)
        self.mValue?.internalBoardsLimitsSegments_property.addEBObserversFrom (&self.mObserversOf_internalBoardsLimitsSegments)
        self.mValue?.modelHeight_property.addEBObserversFrom (&self.mObserversOf_modelHeight)
        self.mValue?.modelHeightUnit_property.addEBObserversFrom (&self.mObserversOf_modelHeightUnit)
        self.mValue?.modelLimitWidth_property.addEBObserversFrom (&self.mObserversOf_modelLimitWidth)
        self.mValue?.modelLimitWidthUnit_property.addEBObserversFrom (&self.mObserversOf_modelLimitWidthUnit)
        self.mValue?.modelWidth_property.addEBObserversFrom (&self.mObserversOf_modelWidth)
        self.mValue?.modelWidthUnit_property.addEBObserversFrom (&self.mObserversOf_modelWidthUnit)
        self.mValue?.myInstances_property.addEBObserversFrom (&self.mObserversOf_myInstances)
        self.mValue?.name_property.addEBObserversFrom (&self.mObserversOf_name)
        self.mValue?.viaShapes_property.addEBObserversFrom (&self.mObserversOf_viaShapes)
        self.mValue?.vias_property.addEBObserversFrom (&self.mObserversOf_vias)
        self.mValue?.viasBezierPaths_property.addEBObserversFrom (&self.mObserversOf_viasBezierPaths)
        self.mValue?.zoom_property.addEBObserversFrom (&self.mObserversOf_zoom)
       //--- Notify observers
        self.postEvent ()
      }
    }
  }

  //····················································································································

  var propval : BoardModel? { return self.mValue }

  var prop : EBSelection <BoardModel?> { return .single (self.mValue) }

  func setProp (_ value : BoardModel?) { self.mValue = value }

  //····················································································································

  @objc func performUndo (_ oldValue : BoardModel?) {
    self.mValue = oldValue
  }

  //····················································································································

  func remove (_ object : BoardModel) {
    if self.mValue === object {
      self.mValue = nil
    }
  }

  //····················································································································
  //   Observable atomic property: artworkName
  //····················································································································

  private var mObserversOf_artworkName = EBWeakEventSet ()

  //····················································································································

  var artworkName_property_selection : EBSelection <String?> {
    if let model = self.propval {
      switch (model.artworkName_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_artworkName (_ inObserver : EBEvent) {
    self.mObserversOf_artworkName.insert (inObserver)
    if let object = self.propval {
      object.artworkName_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_artworkName (_ inObserver : EBEvent) {
    self.mObserversOf_artworkName.remove (inObserver)
    if let object = self.propval {
      object.artworkName_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backComponentNameSegments
  //····················································································································

  private var mObserversOf_backComponentNameSegments = EBWeakEventSet ()

  //····················································································································

  var backComponentNameSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backComponentNameSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backComponentNameSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentNameSegments.insert (inObserver)
    if let object = self.propval {
      object.backComponentNameSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backComponentNameSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentNameSegments.remove (inObserver)
    if let object = self.propval {
      object.backComponentNameSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backComponentNames
  //····················································································································

  private var mObserversOf_backComponentNames = EBWeakEventSet ()

  //····················································································································

  var backComponentNames_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backComponentNames_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backComponentNames (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentNames.insert (inObserver)
    if let object = self.propval {
      object.backComponentNames_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backComponentNames (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentNames.remove (inObserver)
    if let object = self.propval {
      object.backComponentNames_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backComponentNamesBezierPaths
  //····················································································································

  private var mObserversOf_backComponentNamesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backComponentNamesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backComponentNamesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backComponentNamesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentNamesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backComponentNamesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backComponentNamesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentNamesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backComponentNamesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backComponentValueSegments
  //····················································································································

  private var mObserversOf_backComponentValueSegments = EBWeakEventSet ()

  //····················································································································

  var backComponentValueSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backComponentValueSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backComponentValueSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentValueSegments.insert (inObserver)
    if let object = self.propval {
      object.backComponentValueSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backComponentValueSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentValueSegments.remove (inObserver)
    if let object = self.propval {
      object.backComponentValueSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backComponentValues
  //····················································································································

  private var mObserversOf_backComponentValues = EBWeakEventSet ()

  //····················································································································

  var backComponentValues_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backComponentValues_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backComponentValues (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentValues.insert (inObserver)
    if let object = self.propval {
      object.backComponentValues_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backComponentValues (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentValues.remove (inObserver)
    if let object = self.propval {
      object.backComponentValues_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backComponentValuesBezierPaths
  //····················································································································

  private var mObserversOf_backComponentValuesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backComponentValuesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backComponentValuesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backComponentValuesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentValuesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backComponentValuesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backComponentValuesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backComponentValuesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backComponentValuesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backLayoutTexts
  //····················································································································

  private var mObserversOf_backLayoutTexts = EBWeakEventSet ()

  //····················································································································

  var backLayoutTexts_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backLayoutTexts_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backLayoutTexts (_ inObserver : EBEvent) {
    self.mObserversOf_backLayoutTexts.insert (inObserver)
    if let object = self.propval {
      object.backLayoutTexts_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLayoutTexts (_ inObserver : EBEvent) {
    self.mObserversOf_backLayoutTexts.remove (inObserver)
    if let object = self.propval {
      object.backLayoutTexts_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backLayoutTextsBezierPaths
  //····················································································································

  private var mObserversOf_backLayoutTextsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backLayoutTextsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backLayoutTextsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backLayoutTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backLayoutTextsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backLayoutTextsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLayoutTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backLayoutTextsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backLayoutTextsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backLayoutTextsSegments
  //····················································································································

  private var mObserversOf_backLayoutTextsSegments = EBWeakEventSet ()

  //····················································································································

  var backLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backLayoutTextsSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backLayoutTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backLayoutTextsSegments.insert (inObserver)
    if let object = self.propval {
      object.backLayoutTextsSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLayoutTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backLayoutTextsSegments.remove (inObserver)
    if let object = self.propval {
      object.backLayoutTextsSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backLegendLines
  //····················································································································

  private var mObserversOf_backLegendLines = EBWeakEventSet ()

  //····················································································································

  var backLegendLines_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backLegendLines_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backLegendLines (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendLines.insert (inObserver)
    if let object = self.propval {
      object.backLegendLines_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLegendLines (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendLines.remove (inObserver)
    if let object = self.propval {
      object.backLegendLines_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backLegendLinesBezierPaths
  //····················································································································

  private var mObserversOf_backLegendLinesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backLegendLinesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backLegendLinesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backLegendLinesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendLinesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backLegendLinesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLegendLinesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendLinesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backLegendLinesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backLegendLinesSegments
  //····················································································································

  private var mObserversOf_backLegendLinesSegments = EBWeakEventSet ()

  //····················································································································

  var backLegendLinesSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backLegendLinesSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backLegendLinesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendLinesSegments.insert (inObserver)
    if let object = self.propval {
      object.backLegendLinesSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLegendLinesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendLinesSegments.remove (inObserver)
    if let object = self.propval {
      object.backLegendLinesSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backLegendTexts
  //····················································································································

  private var mObserversOf_backLegendTexts = EBWeakEventSet ()

  //····················································································································

  var backLegendTexts_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backLegendTexts_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backLegendTexts (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendTexts.insert (inObserver)
    if let object = self.propval {
      object.backLegendTexts_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLegendTexts (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendTexts.remove (inObserver)
    if let object = self.propval {
      object.backLegendTexts_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backLegendTextsBezierPaths
  //····················································································································

  private var mObserversOf_backLegendTextsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backLegendTextsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backLegendTextsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backLegendTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendTextsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backLegendTextsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLegendTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendTextsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backLegendTextsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backLegendTextsSegments
  //····················································································································

  private var mObserversOf_backLegendTextsSegments = EBWeakEventSet ()

  //····················································································································

  var backLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backLegendTextsSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backLegendTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendTextsSegments.insert (inObserver)
    if let object = self.propval {
      object.backLegendTextsSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backLegendTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backLegendTextsSegments.remove (inObserver)
    if let object = self.propval {
      object.backLegendTextsSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backPackages
  //····················································································································

  private var mObserversOf_backPackages = EBWeakEventSet ()

  //····················································································································

  var backPackages_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backPackages_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backPackages (_ inObserver : EBEvent) {
    self.mObserversOf_backPackages.insert (inObserver)
    if let object = self.propval {
      object.backPackages_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backPackages (_ inObserver : EBEvent) {
    self.mObserversOf_backPackages.remove (inObserver)
    if let object = self.propval {
      object.backPackages_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backPackagesBezierPaths
  //····················································································································

  private var mObserversOf_backPackagesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backPackagesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backPackagesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backPackagesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backPackagesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backPackagesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backPackagesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backPackagesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backPackagesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backPackagesSegments
  //····················································································································

  private var mObserversOf_backPackagesSegments = EBWeakEventSet ()

  //····················································································································

  var backPackagesSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backPackagesSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backPackagesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backPackagesSegments.insert (inObserver)
    if let object = self.propval {
      object.backPackagesSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backPackagesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backPackagesSegments.remove (inObserver)
    if let object = self.propval {
      object.backPackagesSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backPadArray
  //····················································································································

  private var mObserversOf_backPadArray = EBWeakEventSet ()

  //····················································································································

  var backPadArray_property_selection : EBSelection <MergerPadArray?> {
    if let model = self.propval {
      switch (model.backPadArray_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backPadArray (_ inObserver : EBEvent) {
    self.mObserversOf_backPadArray.insert (inObserver)
    if let object = self.propval {
      object.backPadArray_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backPadArray (_ inObserver : EBEvent) {
    self.mObserversOf_backPadArray.remove (inObserver)
    if let object = self.propval {
      object.backPadArray_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backPads
  //····················································································································

  private var mObserversOf_backPads = EBWeakEventSet ()

  //····················································································································

  var backPads_property_selection : EBSelection <[BoardModelPad]> {
    if let model = self.propval {
      switch (model.backPads_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backPads (_ inObserver : EBEvent) {
    self.mObserversOf_backPads.insert (inObserver)
    if let object = self.propval {
      object.backPads_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backPads (_ inObserver : EBEvent) {
    self.mObserversOf_backPads.remove (inObserver)
    if let object = self.propval {
      object.backPads_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backPadsBezierPaths
  //····················································································································

  private var mObserversOf_backPadsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backPadsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backPadsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backPadsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backPadsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backPadsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backPadsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backPadsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backPadsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backTrackSegments
  //····················································································································

  private var mObserversOf_backTrackSegments = EBWeakEventSet ()

  //····················································································································

  var backTrackSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.backTrackSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backTrackSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backTrackSegments.insert (inObserver)
    if let object = self.propval {
      object.backTrackSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backTrackSegments (_ inObserver : EBEvent) {
    self.mObserversOf_backTrackSegments.remove (inObserver)
    if let object = self.propval {
      object.backTrackSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: backTracks
  //····················································································································

  private var mObserversOf_backTracks = EBWeakEventSet ()

  //····················································································································

  var backTracks_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.backTracks_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_backTracks (_ inObserver : EBEvent) {
    self.mObserversOf_backTracks.insert (inObserver)
    if let object = self.propval {
      object.backTracks_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backTracks (_ inObserver : EBEvent) {
    self.mObserversOf_backTracks.remove (inObserver)
    if let object = self.propval {
      object.backTracks_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: backTracksBezierPaths
  //····················································································································

  private var mObserversOf_backTracksBezierPaths = EBWeakEventSet ()

  //····················································································································

  var backTracksBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.backTracksBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_backTracksBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backTracksBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.backTracksBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_backTracksBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_backTracksBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.backTracksBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardLimits
  //····················································································································

  private var mObserversOf_boardLimits = EBWeakEventSet ()

  //····················································································································

  var boardLimits_property_selection : EBSelection <MergerBoardLimits?> {
    if let model = self.propval {
      switch (model.boardLimits_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardLimits (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimits.insert (inObserver)
    if let object = self.propval {
      object.boardLimits_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardLimits (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimits.remove (inObserver)
    if let object = self.propval {
      object.boardLimits_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardLimitsBezierPaths
  //····················································································································

  private var mObserversOf_boardLimitsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var boardLimitsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.boardLimitsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardLimitsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimitsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.boardLimitsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardLimitsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimitsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.boardLimitsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: drillSegments
  //····················································································································

  private var mObserversOf_drillSegments = EBWeakEventSet ()

  //····················································································································

  var drillSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.drillSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_drillSegments (_ inObserver : EBEvent) {
    self.mObserversOf_drillSegments.insert (inObserver)
    if let object = self.propval {
      object.drillSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_drillSegments (_ inObserver : EBEvent) {
    self.mObserversOf_drillSegments.remove (inObserver)
    if let object = self.propval {
      object.drillSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: drills
  //····················································································································

  private var mObserversOf_drills = EBWeakEventSet ()

  //····················································································································

  var drills_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.drills_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_drills (_ inObserver : EBEvent) {
    self.mObserversOf_drills.insert (inObserver)
    if let object = self.propval {
      object.drills_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_drills (_ inObserver : EBEvent) {
    self.mObserversOf_drills.remove (inObserver)
    if let object = self.propval {
      object.drills_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontComponentNameSegments
  //····················································································································

  private var mObserversOf_frontComponentNameSegments = EBWeakEventSet ()

  //····················································································································

  var frontComponentNameSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontComponentNameSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontComponentNameSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentNameSegments.insert (inObserver)
    if let object = self.propval {
      object.frontComponentNameSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontComponentNameSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentNameSegments.remove (inObserver)
    if let object = self.propval {
      object.frontComponentNameSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontComponentNames
  //····················································································································

  private var mObserversOf_frontComponentNames = EBWeakEventSet ()

  //····················································································································

  var frontComponentNames_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontComponentNames_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontComponentNames (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentNames.insert (inObserver)
    if let object = self.propval {
      object.frontComponentNames_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontComponentNames (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentNames.remove (inObserver)
    if let object = self.propval {
      object.frontComponentNames_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontComponentNamesBezierPaths
  //····················································································································

  private var mObserversOf_frontComponentNamesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontComponentNamesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontComponentNamesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontComponentNamesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentNamesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontComponentNamesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontComponentNamesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentNamesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontComponentNamesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontComponentValueSegments
  //····················································································································

  private var mObserversOf_frontComponentValueSegments = EBWeakEventSet ()

  //····················································································································

  var frontComponentValueSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontComponentValueSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontComponentValueSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentValueSegments.insert (inObserver)
    if let object = self.propval {
      object.frontComponentValueSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontComponentValueSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentValueSegments.remove (inObserver)
    if let object = self.propval {
      object.frontComponentValueSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontComponentValues
  //····················································································································

  private var mObserversOf_frontComponentValues = EBWeakEventSet ()

  //····················································································································

  var frontComponentValues_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontComponentValues_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontComponentValues (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentValues.insert (inObserver)
    if let object = self.propval {
      object.frontComponentValues_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontComponentValues (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentValues.remove (inObserver)
    if let object = self.propval {
      object.frontComponentValues_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontComponentValuesBezierPaths
  //····················································································································

  private var mObserversOf_frontComponentValuesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontComponentValuesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontComponentValuesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontComponentValuesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentValuesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontComponentValuesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontComponentValuesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontComponentValuesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontComponentValuesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontLayoutTexts
  //····················································································································

  private var mObserversOf_frontLayoutTexts = EBWeakEventSet ()

  //····················································································································

  var frontLayoutTexts_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontLayoutTexts_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLayoutTexts (_ inObserver : EBEvent) {
    self.mObserversOf_frontLayoutTexts.insert (inObserver)
    if let object = self.propval {
      object.frontLayoutTexts_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLayoutTexts (_ inObserver : EBEvent) {
    self.mObserversOf_frontLayoutTexts.remove (inObserver)
    if let object = self.propval {
      object.frontLayoutTexts_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontLayoutTextsBezierPaths
  //····················································································································

  private var mObserversOf_frontLayoutTextsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontLayoutTextsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontLayoutTextsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLayoutTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontLayoutTextsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontLayoutTextsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLayoutTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontLayoutTextsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontLayoutTextsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontLayoutTextsSegments
  //····················································································································

  private var mObserversOf_frontLayoutTextsSegments = EBWeakEventSet ()

  //····················································································································

  var frontLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontLayoutTextsSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLayoutTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontLayoutTextsSegments.insert (inObserver)
    if let object = self.propval {
      object.frontLayoutTextsSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLayoutTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontLayoutTextsSegments.remove (inObserver)
    if let object = self.propval {
      object.frontLayoutTextsSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontLegendLines
  //····················································································································

  private var mObserversOf_frontLegendLines = EBWeakEventSet ()

  //····················································································································

  var frontLegendLines_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontLegendLines_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLegendLines (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendLines.insert (inObserver)
    if let object = self.propval {
      object.frontLegendLines_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLegendLines (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendLines.remove (inObserver)
    if let object = self.propval {
      object.frontLegendLines_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontLegendLinesBezierPaths
  //····················································································································

  private var mObserversOf_frontLegendLinesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontLegendLinesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontLegendLinesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLegendLinesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendLinesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontLegendLinesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLegendLinesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendLinesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontLegendLinesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontLegendLinesSegments
  //····················································································································

  private var mObserversOf_frontLegendLinesSegments = EBWeakEventSet ()

  //····················································································································

  var frontLegendLinesSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontLegendLinesSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLegendLinesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendLinesSegments.insert (inObserver)
    if let object = self.propval {
      object.frontLegendLinesSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLegendLinesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendLinesSegments.remove (inObserver)
    if let object = self.propval {
      object.frontLegendLinesSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontLegendTexts
  //····················································································································

  private var mObserversOf_frontLegendTexts = EBWeakEventSet ()

  //····················································································································

  var frontLegendTexts_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontLegendTexts_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLegendTexts (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendTexts.insert (inObserver)
    if let object = self.propval {
      object.frontLegendTexts_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLegendTexts (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendTexts.remove (inObserver)
    if let object = self.propval {
      object.frontLegendTexts_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontLegendTextsBezierPaths
  //····················································································································

  private var mObserversOf_frontLegendTextsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontLegendTextsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontLegendTextsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLegendTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendTextsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontLegendTextsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLegendTextsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendTextsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontLegendTextsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontLegendTextsSegments
  //····················································································································

  private var mObserversOf_frontLegendTextsSegments = EBWeakEventSet ()

  //····················································································································

  var frontLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontLegendTextsSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontLegendTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendTextsSegments.insert (inObserver)
    if let object = self.propval {
      object.frontLegendTextsSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontLegendTextsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontLegendTextsSegments.remove (inObserver)
    if let object = self.propval {
      object.frontLegendTextsSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontPackages
  //····················································································································

  private var mObserversOf_frontPackages = EBWeakEventSet ()

  //····················································································································

  var frontPackages_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontPackages_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontPackages (_ inObserver : EBEvent) {
    self.mObserversOf_frontPackages.insert (inObserver)
    if let object = self.propval {
      object.frontPackages_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontPackages (_ inObserver : EBEvent) {
    self.mObserversOf_frontPackages.remove (inObserver)
    if let object = self.propval {
      object.frontPackages_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontPackagesBezierPaths
  //····················································································································

  private var mObserversOf_frontPackagesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontPackagesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontPackagesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontPackagesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontPackagesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontPackagesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontPackagesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontPackagesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontPackagesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontPackagesSegments
  //····················································································································

  private var mObserversOf_frontPackagesSegments = EBWeakEventSet ()

  //····················································································································

  var frontPackagesSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontPackagesSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontPackagesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontPackagesSegments.insert (inObserver)
    if let object = self.propval {
      object.frontPackagesSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontPackagesSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontPackagesSegments.remove (inObserver)
    if let object = self.propval {
      object.frontPackagesSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontPadArray
  //····················································································································

  private var mObserversOf_frontPadArray = EBWeakEventSet ()

  //····················································································································

  var frontPadArray_property_selection : EBSelection <MergerPadArray?> {
    if let model = self.propval {
      switch (model.frontPadArray_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontPadArray (_ inObserver : EBEvent) {
    self.mObserversOf_frontPadArray.insert (inObserver)
    if let object = self.propval {
      object.frontPadArray_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontPadArray (_ inObserver : EBEvent) {
    self.mObserversOf_frontPadArray.remove (inObserver)
    if let object = self.propval {
      object.frontPadArray_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontPads
  //····················································································································

  private var mObserversOf_frontPads = EBWeakEventSet ()

  //····················································································································

  var frontPads_property_selection : EBSelection <[BoardModelPad]> {
    if let model = self.propval {
      switch (model.frontPads_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontPads (_ inObserver : EBEvent) {
    self.mObserversOf_frontPads.insert (inObserver)
    if let object = self.propval {
      object.frontPads_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontPads (_ inObserver : EBEvent) {
    self.mObserversOf_frontPads.remove (inObserver)
    if let object = self.propval {
      object.frontPads_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontPadsBezierPaths
  //····················································································································

  private var mObserversOf_frontPadsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontPadsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontPadsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontPadsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontPadsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontPadsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontPadsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontPadsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontPadsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontTrackSegments
  //····················································································································

  private var mObserversOf_frontTrackSegments = EBWeakEventSet ()

  //····················································································································

  var frontTrackSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.frontTrackSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontTrackSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontTrackSegments.insert (inObserver)
    if let object = self.propval {
      object.frontTrackSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontTrackSegments (_ inObserver : EBEvent) {
    self.mObserversOf_frontTrackSegments.remove (inObserver)
    if let object = self.propval {
      object.frontTrackSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: frontTracks
  //····················································································································

  private var mObserversOf_frontTracks = EBWeakEventSet ()

  //····················································································································

  var frontTracks_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.frontTracks_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_frontTracks (_ inObserver : EBEvent) {
    self.mObserversOf_frontTracks.insert (inObserver)
    if let object = self.propval {
      object.frontTracks_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontTracks (_ inObserver : EBEvent) {
    self.mObserversOf_frontTracks.remove (inObserver)
    if let object = self.propval {
      object.frontTracks_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: frontTracksBezierPaths
  //····················································································································

  private var mObserversOf_frontTracksBezierPaths = EBWeakEventSet ()

  //····················································································································

  var frontTracksBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.frontTracksBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_frontTracksBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontTracksBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.frontTracksBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_frontTracksBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_frontTracksBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.frontTracksBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: holesBezierPaths
  //····················································································································

  private var mObserversOf_holesBezierPaths = EBWeakEventSet ()

  //····················································································································

  var holesBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.holesBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_holesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_holesBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.holesBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_holesBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_holesBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.holesBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: imageForInstances
  //····················································································································

  private var mObserversOf_imageForInstances = EBWeakEventSet ()

  //····················································································································

  var imageForInstances_property_selection : EBSelection <EBShape?> {
    if let model = self.propval {
      switch (model.imageForInstances_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_imageForInstances (_ inObserver : EBEvent) {
    self.mObserversOf_imageForInstances.insert (inObserver)
    if let object = self.propval {
      object.imageForInstances_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_imageForInstances (_ inObserver : EBEvent) {
    self.mObserversOf_imageForInstances.remove (inObserver)
    if let object = self.propval {
      object.imageForInstances_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: imageForModel
  //····················································································································

  private var mObserversOf_imageForModel = EBWeakEventSet ()

  //····················································································································

  var imageForModel_property_selection : EBSelection <EBShape?> {
    if let model = self.propval {
      switch (model.imageForModel_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_imageForModel (_ inObserver : EBEvent) {
    self.mObserversOf_imageForModel.insert (inObserver)
    if let object = self.propval {
      object.imageForModel_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_imageForModel (_ inObserver : EBEvent) {
    self.mObserversOf_imageForModel.remove (inObserver)
    if let object = self.propval {
      object.imageForModel_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: instanceCount
  //····················································································································

  private var mObserversOf_instanceCount = EBWeakEventSet ()

  //····················································································································

  var instanceCount_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.instanceCount_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_instanceCount (_ inObserver : EBEvent) {
    self.mObserversOf_instanceCount.insert (inObserver)
    if let object = self.propval {
      object.instanceCount_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_instanceCount (_ inObserver : EBEvent) {
    self.mObserversOf_instanceCount.remove (inObserver)
    if let object = self.propval {
      object.instanceCount_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: internalBoardsLimits
  //····················································································································

  private var mObserversOf_internalBoardsLimits = EBWeakEventSet ()

  //····················································································································

  var internalBoardsLimits_property_selection : EBSelection <[SegmentEntity]> {
    if let model = self.propval {
      switch (model.internalBoardsLimits_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_internalBoardsLimits (_ inObserver : EBEvent) {
    self.mObserversOf_internalBoardsLimits.insert (inObserver)
    if let object = self.propval {
      object.internalBoardsLimits_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_internalBoardsLimits (_ inObserver : EBEvent) {
    self.mObserversOf_internalBoardsLimits.remove (inObserver)
    if let object = self.propval {
      object.internalBoardsLimits_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: internalBoardsLimitsBezierPaths
  //····················································································································

  private var mObserversOf_internalBoardsLimitsBezierPaths = EBWeakEventSet ()

  //····················································································································

  var internalBoardsLimitsBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.internalBoardsLimitsBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_internalBoardsLimitsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_internalBoardsLimitsBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.internalBoardsLimitsBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_internalBoardsLimitsBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_internalBoardsLimitsBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.internalBoardsLimitsBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: internalBoardsLimitsSegments
  //····················································································································

  private var mObserversOf_internalBoardsLimitsSegments = EBWeakEventSet ()

  //····················································································································

  var internalBoardsLimitsSegments_property_selection : EBSelection <MergerSegmentArray?> {
    if let model = self.propval {
      switch (model.internalBoardsLimitsSegments_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_internalBoardsLimitsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_internalBoardsLimitsSegments.insert (inObserver)
    if let object = self.propval {
      object.internalBoardsLimitsSegments_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_internalBoardsLimitsSegments (_ inObserver : EBEvent) {
    self.mObserversOf_internalBoardsLimitsSegments.remove (inObserver)
    if let object = self.propval {
      object.internalBoardsLimitsSegments_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelHeight
  //····················································································································

  private var mObserversOf_modelHeight = EBWeakEventSet ()

  //····················································································································

  var modelHeight_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.modelHeight_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelHeight (_ inObserver : EBEvent) {
    self.mObserversOf_modelHeight.insert (inObserver)
    if let object = self.propval {
      object.modelHeight_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelHeight (_ inObserver : EBEvent) {
    self.mObserversOf_modelHeight.remove (inObserver)
    if let object = self.propval {
      object.modelHeight_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelHeightUnit
  //····················································································································

  private var mObserversOf_modelHeightUnit = EBWeakEventSet ()

  //····················································································································

  var modelHeightUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.modelHeightUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelHeightUnit (_ inObserver : EBEvent) {
    self.mObserversOf_modelHeightUnit.insert (inObserver)
    if let object = self.propval {
      object.modelHeightUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelHeightUnit (_ inObserver : EBEvent) {
    self.mObserversOf_modelHeightUnit.remove (inObserver)
    if let object = self.propval {
      object.modelHeightUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelLimitWidth
  //····················································································································

  private var mObserversOf_modelLimitWidth = EBWeakEventSet ()

  //····················································································································

  var modelLimitWidth_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.modelLimitWidth_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelLimitWidth (_ inObserver : EBEvent) {
    self.mObserversOf_modelLimitWidth.insert (inObserver)
    if let object = self.propval {
      object.modelLimitWidth_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelLimitWidth (_ inObserver : EBEvent) {
    self.mObserversOf_modelLimitWidth.remove (inObserver)
    if let object = self.propval {
      object.modelLimitWidth_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelLimitWidthUnit
  //····················································································································

  private var mObserversOf_modelLimitWidthUnit = EBWeakEventSet ()

  //····················································································································

  var modelLimitWidthUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.modelLimitWidthUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelLimitWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_modelLimitWidthUnit.insert (inObserver)
    if let object = self.propval {
      object.modelLimitWidthUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelLimitWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_modelLimitWidthUnit.remove (inObserver)
    if let object = self.propval {
      object.modelLimitWidthUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelWidth
  //····················································································································

  private var mObserversOf_modelWidth = EBWeakEventSet ()

  //····················································································································

  var modelWidth_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.modelWidth_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelWidth (_ inObserver : EBEvent) {
    self.mObserversOf_modelWidth.insert (inObserver)
    if let object = self.propval {
      object.modelWidth_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelWidth (_ inObserver : EBEvent) {
    self.mObserversOf_modelWidth.remove (inObserver)
    if let object = self.propval {
      object.modelWidth_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelWidthUnit
  //····················································································································

  private var mObserversOf_modelWidthUnit = EBWeakEventSet ()

  //····················································································································

  var modelWidthUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.modelWidthUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_modelWidthUnit.insert (inObserver)
    if let object = self.propval {
      object.modelWidthUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_modelWidthUnit.remove (inObserver)
    if let object = self.propval {
      object.modelWidthUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: myInstances
  //····················································································································

  private var mObserversOf_myInstances = EBWeakEventSet ()

  //····················································································································

  var myInstances_property_selection : EBSelection <[MergerBoardInstance]> {
    if let model = self.propval {
      switch (model.myInstances_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_myInstances (_ inObserver : EBEvent) {
    self.mObserversOf_myInstances.insert (inObserver)
    if let object = self.propval {
      object.myInstances_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_myInstances (_ inObserver : EBEvent) {
    self.mObserversOf_myInstances.remove (inObserver)
    if let object = self.propval {
      object.myInstances_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: name
  //····················································································································

  private var mObserversOf_name = EBWeakEventSet ()

  //····················································································································

  var name_property_selection : EBSelection <String?> {
    if let model = self.propval {
      switch (model.name_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_name (_ inObserver : EBEvent) {
    self.mObserversOf_name.insert (inObserver)
    if let object = self.propval {
      object.name_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_name (_ inObserver : EBEvent) {
    self.mObserversOf_name.remove (inObserver)
    if let object = self.propval {
      object.name_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: viaShapes
  //····················································································································

  private var mObserversOf_viaShapes = EBWeakEventSet ()

  //····················································································································

  var viaShapes_property_selection : EBSelection <MergerViaShapeArray?> {
    if let model = self.propval {
      switch (model.viaShapes_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_viaShapes (_ inObserver : EBEvent) {
    self.mObserversOf_viaShapes.insert (inObserver)
    if let object = self.propval {
      object.viaShapes_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_viaShapes (_ inObserver : EBEvent) {
    self.mObserversOf_viaShapes.remove (inObserver)
    if let object = self.propval {
      object.viaShapes_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: vias
  //····················································································································

  private var mObserversOf_vias = EBWeakEventSet ()

  //····················································································································

  var vias_property_selection : EBSelection <[BoardModelVia]> {
    if let model = self.propval {
      switch (model.vias_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_vias (_ inObserver : EBEvent) {
    self.mObserversOf_vias.insert (inObserver)
    if let object = self.propval {
      object.vias_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_vias (_ inObserver : EBEvent) {
    self.mObserversOf_vias.remove (inObserver)
    if let object = self.propval {
      object.vias_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: viasBezierPaths
  //····················································································································

  private var mObserversOf_viasBezierPaths = EBWeakEventSet ()

  //····················································································································

  var viasBezierPaths_property_selection : EBSelection <BezierPathArray?> {
    if let model = self.propval {
      switch (model.viasBezierPaths_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_viasBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_viasBezierPaths.insert (inObserver)
    if let object = self.propval {
      object.viasBezierPaths_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_viasBezierPaths (_ inObserver : EBEvent) {
    self.mObserversOf_viasBezierPaths.remove (inObserver)
    if let object = self.propval {
      object.viasBezierPaths_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: zoom
  //····················································································································

  private var mObserversOf_zoom = EBWeakEventSet ()

  //····················································································································

  var zoom_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.zoom_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_zoom (_ inObserver : EBEvent) {
    self.mObserversOf_zoom.insert (inObserver)
    if let object = self.propval {
      object.zoom_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_zoom (_ inObserver : EBEvent) {
    self.mObserversOf_zoom.remove (inObserver)
    if let object = self.propval {
      object.zoom_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

}
#endif

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    To one relationship: myRoot
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#if !NEWTOONE
final class ToOneRelationship_MergerBoardInstance_myRoot : EBAbstractProperty {

  //····················································································································
  //   Value explorer
  //····················································································································

  var mValueExplorer : NSButton? {
    didSet {
      if let unwrappedExplorer = self.mValueExplorer {
        switch prop {
        case .empty, .multiple :
          break ;
        case .single (let v) :
          updateManagedObjectToOneRelationshipDisplay (object: v, button:unwrappedExplorer)
        }
      }
    }
  }

  //····················································································································

  weak var owner : MergerBoardInstance? { // SOULD BE WEAK
    didSet {
      if let unwrappedExplorer = self.mValueExplorer {
        updateManagedObjectToOneRelationshipDisplay (object: propval, button: unwrappedExplorer)
      }
    }
  }
 
  //····················································································································

  private var mValue : MergerRoot? {
    didSet {
      if let unwrappedOwner = self.owner, oldValue !== self.mValue {
      //--- Register old value in undo manager
        unwrappedOwner.ebUndoManager?.registerUndo (withTarget:self, selector:#selector(performUndo(_:)), object:oldValue)
      //--- Update explorer
        if let unwrappedExplorer = self.mValueExplorer {
          updateManagedObjectToOneRelationshipDisplay (object: self.mValue, button: unwrappedExplorer)
        }
      //--- Reset old opposite relation ship
        oldValue?.boardInstances_property.remove (unwrappedOwner)
      //--- Set new opposite relation ship
        self.mValue?.boardInstances_property.add (unwrappedOwner)
      //--- Remove property observers of old object
        oldValue?.arrowMagnitude_property.removeEBObserversFrom (&self.mObserversOf_arrowMagnitude)
        oldValue?.arrowMagnitudeUnit_property.removeEBObserversFrom (&self.mObserversOf_arrowMagnitudeUnit)
        oldValue?.artworkName_property.removeEBObserversFrom (&self.mObserversOf_artworkName)
        oldValue?.automaticBoardSize_property.removeEBObserversFrom (&self.mObserversOf_automaticBoardSize)
        oldValue?.boardDisplayRect_property.removeEBObserversFrom (&self.mObserversOf_boardDisplayRect)
        oldValue?.boardHeight_property.removeEBObserversFrom (&self.mObserversOf_boardHeight)
        oldValue?.boardHeightUnit_property.removeEBObserversFrom (&self.mObserversOf_boardHeightUnit)
        oldValue?.boardInstances_property.removeEBObserversFrom (&self.mObserversOf_boardInstances)
        oldValue?.boardLimitWidth_property.removeEBObserversFrom (&self.mObserversOf_boardLimitWidth)
        oldValue?.boardLimitWidthUnit_property.removeEBObserversFrom (&self.mObserversOf_boardLimitWidthUnit)
        oldValue?.boardManualHeight_property.removeEBObserversFrom (&self.mObserversOf_boardManualHeight)
        oldValue?.boardManualWidth_property.removeEBObserversFrom (&self.mObserversOf_boardManualWidth)
        oldValue?.boardModels_property.removeEBObserversFrom (&self.mObserversOf_boardModels)
        oldValue?.boardOutlineRectDisplay_property.removeEBObserversFrom (&self.mObserversOf_boardOutlineRectDisplay)
        oldValue?.boardRect_property.removeEBObserversFrom (&self.mObserversOf_boardRect)
        oldValue?.boardWidth_property.removeEBObserversFrom (&self.mObserversOf_boardWidth)
        oldValue?.boardWidthUnit_property.removeEBObserversFrom (&self.mObserversOf_boardWidthUnit)
        oldValue?.generateGerberProductFile_property.removeEBObserversFrom (&self.mObserversOf_generateGerberProductFile)
        oldValue?.generatePDFProductFile_property.removeEBObserversFrom (&self.mObserversOf_generatePDFProductFile)
        oldValue?.generatedBoardArchiveFormat_property.removeEBObserversFrom (&self.mObserversOf_generatedBoardArchiveFormat)
        oldValue?.modelNames_property.removeEBObserversFrom (&self.mObserversOf_modelNames)
        oldValue?.overlapingArrangment_property.removeEBObserversFrom (&self.mObserversOf_overlapingArrangment)
        oldValue?.selectedBoardXUnit_property.removeEBObserversFrom (&self.mObserversOf_selectedBoardXUnit)
        oldValue?.selectedBoardYUnit_property.removeEBObserversFrom (&self.mObserversOf_selectedBoardYUnit)
        oldValue?.selectedPageIndex_property.removeEBObserversFrom (&self.mObserversOf_selectedPageIndex)
        oldValue?.shiftArrowMagnitude_property.removeEBObserversFrom (&self.mObserversOf_shiftArrowMagnitude)
        oldValue?.shiftArrowMagnitudeUnit_property.removeEBObserversFrom (&self.mObserversOf_shiftArrowMagnitudeUnit)
        oldValue?.zoom_property.removeEBObserversFrom (&self.mObserversOf_zoom)
      //--- Add property observers to new object
        self.mValue?.arrowMagnitude_property.addEBObserversFrom (&self.mObserversOf_arrowMagnitude)
        self.mValue?.arrowMagnitudeUnit_property.addEBObserversFrom (&self.mObserversOf_arrowMagnitudeUnit)
        self.mValue?.artworkName_property.addEBObserversFrom (&self.mObserversOf_artworkName)
        self.mValue?.automaticBoardSize_property.addEBObserversFrom (&self.mObserversOf_automaticBoardSize)
        self.mValue?.boardDisplayRect_property.addEBObserversFrom (&self.mObserversOf_boardDisplayRect)
        self.mValue?.boardHeight_property.addEBObserversFrom (&self.mObserversOf_boardHeight)
        self.mValue?.boardHeightUnit_property.addEBObserversFrom (&self.mObserversOf_boardHeightUnit)
        self.mValue?.boardInstances_property.addEBObserversFrom (&self.mObserversOf_boardInstances)
        self.mValue?.boardLimitWidth_property.addEBObserversFrom (&self.mObserversOf_boardLimitWidth)
        self.mValue?.boardLimitWidthUnit_property.addEBObserversFrom (&self.mObserversOf_boardLimitWidthUnit)
        self.mValue?.boardManualHeight_property.addEBObserversFrom (&self.mObserversOf_boardManualHeight)
        self.mValue?.boardManualWidth_property.addEBObserversFrom (&self.mObserversOf_boardManualWidth)
        self.mValue?.boardModels_property.addEBObserversFrom (&self.mObserversOf_boardModels)
        self.mValue?.boardOutlineRectDisplay_property.addEBObserversFrom (&self.mObserversOf_boardOutlineRectDisplay)
        self.mValue?.boardRect_property.addEBObserversFrom (&self.mObserversOf_boardRect)
        self.mValue?.boardWidth_property.addEBObserversFrom (&self.mObserversOf_boardWidth)
        self.mValue?.boardWidthUnit_property.addEBObserversFrom (&self.mObserversOf_boardWidthUnit)
        self.mValue?.generateGerberProductFile_property.addEBObserversFrom (&self.mObserversOf_generateGerberProductFile)
        self.mValue?.generatePDFProductFile_property.addEBObserversFrom (&self.mObserversOf_generatePDFProductFile)
        self.mValue?.generatedBoardArchiveFormat_property.addEBObserversFrom (&self.mObserversOf_generatedBoardArchiveFormat)
        self.mValue?.modelNames_property.addEBObserversFrom (&self.mObserversOf_modelNames)
        self.mValue?.overlapingArrangment_property.addEBObserversFrom (&self.mObserversOf_overlapingArrangment)
        self.mValue?.selectedBoardXUnit_property.addEBObserversFrom (&self.mObserversOf_selectedBoardXUnit)
        self.mValue?.selectedBoardYUnit_property.addEBObserversFrom (&self.mObserversOf_selectedBoardYUnit)
        self.mValue?.selectedPageIndex_property.addEBObserversFrom (&self.mObserversOf_selectedPageIndex)
        self.mValue?.shiftArrowMagnitude_property.addEBObserversFrom (&self.mObserversOf_shiftArrowMagnitude)
        self.mValue?.shiftArrowMagnitudeUnit_property.addEBObserversFrom (&self.mObserversOf_shiftArrowMagnitudeUnit)
        self.mValue?.zoom_property.addEBObserversFrom (&self.mObserversOf_zoom)
       //--- Notify observers
        self.postEvent ()
      }
    }
  }

  //····················································································································

  var propval : MergerRoot? { return self.mValue }

  var prop : EBSelection <MergerRoot?> { return .single (self.mValue) }

  func setProp (_ value : MergerRoot?) { self.mValue = value }

  //····················································································································

  @objc func performUndo (_ oldValue : MergerRoot?) {
    self.mValue = oldValue
  }

  //····················································································································

  func remove (_ object : MergerRoot) {
    if self.mValue === object {
      self.mValue = nil
    }
  }

  //····················································································································
  //   Observable atomic property: arrowMagnitude
  //····················································································································

  private var mObserversOf_arrowMagnitude = EBWeakEventSet ()

  //····················································································································

  var arrowMagnitude_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.arrowMagnitude_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_arrowMagnitude (_ inObserver : EBEvent) {
    self.mObserversOf_arrowMagnitude.insert (inObserver)
    if let object = self.propval {
      object.arrowMagnitude_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_arrowMagnitude (_ inObserver : EBEvent) {
    self.mObserversOf_arrowMagnitude.remove (inObserver)
    if let object = self.propval {
      object.arrowMagnitude_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: arrowMagnitudeUnit
  //····················································································································

  private var mObserversOf_arrowMagnitudeUnit = EBWeakEventSet ()

  //····················································································································

  var arrowMagnitudeUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.arrowMagnitudeUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_arrowMagnitudeUnit (_ inObserver : EBEvent) {
    self.mObserversOf_arrowMagnitudeUnit.insert (inObserver)
    if let object = self.propval {
      object.arrowMagnitudeUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_arrowMagnitudeUnit (_ inObserver : EBEvent) {
    self.mObserversOf_arrowMagnitudeUnit.remove (inObserver)
    if let object = self.propval {
      object.arrowMagnitudeUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: artworkName
  //····················································································································

  private var mObserversOf_artworkName = EBWeakEventSet ()

  //····················································································································

  var artworkName_property_selection : EBSelection <String?> {
    if let model = self.propval {
      switch (model.artworkName_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_artworkName (_ inObserver : EBEvent) {
    self.mObserversOf_artworkName.insert (inObserver)
    if let object = self.propval {
      object.artworkName_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_artworkName (_ inObserver : EBEvent) {
    self.mObserversOf_artworkName.remove (inObserver)
    if let object = self.propval {
      object.artworkName_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: automaticBoardSize
  //····················································································································

  private var mObserversOf_automaticBoardSize = EBWeakEventSet ()

  //····················································································································

  var automaticBoardSize_property_selection : EBSelection <Bool?> {
    if let model = self.propval {
      switch (model.automaticBoardSize_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_automaticBoardSize (_ inObserver : EBEvent) {
    self.mObserversOf_automaticBoardSize.insert (inObserver)
    if let object = self.propval {
      object.automaticBoardSize_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_automaticBoardSize (_ inObserver : EBEvent) {
    self.mObserversOf_automaticBoardSize.remove (inObserver)
    if let object = self.propval {
      object.automaticBoardSize_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardDisplayRect
  //····················································································································

  private var mObserversOf_boardDisplayRect = EBWeakEventSet ()

  //····················································································································

  var boardDisplayRect_property_selection : EBSelection <CanariRect?> {
    if let model = self.propval {
      switch (model.boardDisplayRect_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardDisplayRect (_ inObserver : EBEvent) {
    self.mObserversOf_boardDisplayRect.insert (inObserver)
    if let object = self.propval {
      object.boardDisplayRect_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardDisplayRect (_ inObserver : EBEvent) {
    self.mObserversOf_boardDisplayRect.remove (inObserver)
    if let object = self.propval {
      object.boardDisplayRect_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardHeight
  //····················································································································

  private var mObserversOf_boardHeight = EBWeakEventSet ()

  //····················································································································

  var boardHeight_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardHeight_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardHeight (_ inObserver : EBEvent) {
    self.mObserversOf_boardHeight.insert (inObserver)
    if let object = self.propval {
      object.boardHeight_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardHeight (_ inObserver : EBEvent) {
    self.mObserversOf_boardHeight.remove (inObserver)
    if let object = self.propval {
      object.boardHeight_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardHeightUnit
  //····················································································································

  private var mObserversOf_boardHeightUnit = EBWeakEventSet ()

  //····················································································································

  var boardHeightUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardHeightUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardHeightUnit (_ inObserver : EBEvent) {
    self.mObserversOf_boardHeightUnit.insert (inObserver)
    if let object = self.propval {
      object.boardHeightUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardHeightUnit (_ inObserver : EBEvent) {
    self.mObserversOf_boardHeightUnit.remove (inObserver)
    if let object = self.propval {
      object.boardHeightUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: boardInstances
  //····················································································································

  private var mObserversOf_boardInstances = EBWeakEventSet ()

  //····················································································································

  var boardInstances_property_selection : EBSelection <[MergerBoardInstance]> {
    if let model = self.propval {
      switch (model.boardInstances_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_boardInstances (_ inObserver : EBEvent) {
    self.mObserversOf_boardInstances.insert (inObserver)
    if let object = self.propval {
      object.boardInstances_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardInstances (_ inObserver : EBEvent) {
    self.mObserversOf_boardInstances.remove (inObserver)
    if let object = self.propval {
      object.boardInstances_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardLimitWidth
  //····················································································································

  private var mObserversOf_boardLimitWidth = EBWeakEventSet ()

  //····················································································································

  var boardLimitWidth_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardLimitWidth_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardLimitWidth (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimitWidth.insert (inObserver)
    if let object = self.propval {
      object.boardLimitWidth_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardLimitWidth (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimitWidth.remove (inObserver)
    if let object = self.propval {
      object.boardLimitWidth_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardLimitWidthUnit
  //····················································································································

  private var mObserversOf_boardLimitWidthUnit = EBWeakEventSet ()

  //····················································································································

  var boardLimitWidthUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardLimitWidthUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardLimitWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimitWidthUnit.insert (inObserver)
    if let object = self.propval {
      object.boardLimitWidthUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardLimitWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_boardLimitWidthUnit.remove (inObserver)
    if let object = self.propval {
      object.boardLimitWidthUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardManualHeight
  //····················································································································

  private var mObserversOf_boardManualHeight = EBWeakEventSet ()

  //····················································································································

  var boardManualHeight_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardManualHeight_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardManualHeight (_ inObserver : EBEvent) {
    self.mObserversOf_boardManualHeight.insert (inObserver)
    if let object = self.propval {
      object.boardManualHeight_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardManualHeight (_ inObserver : EBEvent) {
    self.mObserversOf_boardManualHeight.remove (inObserver)
    if let object = self.propval {
      object.boardManualHeight_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardManualWidth
  //····················································································································

  private var mObserversOf_boardManualWidth = EBWeakEventSet ()

  //····················································································································

  var boardManualWidth_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardManualWidth_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardManualWidth (_ inObserver : EBEvent) {
    self.mObserversOf_boardManualWidth.insert (inObserver)
    if let object = self.propval {
      object.boardManualWidth_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardManualWidth (_ inObserver : EBEvent) {
    self.mObserversOf_boardManualWidth.remove (inObserver)
    if let object = self.propval {
      object.boardManualWidth_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable toMany property: boardModels
  //····················································································································

  private var mObserversOf_boardModels = EBWeakEventSet ()

  //····················································································································

  var boardModels_property_selection : EBSelection <[BoardModel]> {
    if let model = self.propval {
      switch (model.boardModels_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .empty
    }
  }

  //····················································································································

  final func addEBObserverOf_boardModels (_ inObserver : EBEvent) {
    self.mObserversOf_boardModels.insert (inObserver)
    if let object = self.propval {
      object.boardModels_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardModels (_ inObserver : EBEvent) {
    self.mObserversOf_boardModels.remove (inObserver)
    if let object = self.propval {
      object.boardModels_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardOutlineRectDisplay
  //····················································································································

  private var mObserversOf_boardOutlineRectDisplay = EBWeakEventSet ()

  //····················································································································

  var boardOutlineRectDisplay_property_selection : EBSelection <EBShape?> {
    if let model = self.propval {
      switch (model.boardOutlineRectDisplay_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardOutlineRectDisplay (_ inObserver : EBEvent) {
    self.mObserversOf_boardOutlineRectDisplay.insert (inObserver)
    if let object = self.propval {
      object.boardOutlineRectDisplay_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardOutlineRectDisplay (_ inObserver : EBEvent) {
    self.mObserversOf_boardOutlineRectDisplay.remove (inObserver)
    if let object = self.propval {
      object.boardOutlineRectDisplay_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardRect
  //····················································································································

  private var mObserversOf_boardRect = EBWeakEventSet ()

  //····················································································································

  var boardRect_property_selection : EBSelection <CanariRect?> {
    if let model = self.propval {
      switch (model.boardRect_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardRect (_ inObserver : EBEvent) {
    self.mObserversOf_boardRect.insert (inObserver)
    if let object = self.propval {
      object.boardRect_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardRect (_ inObserver : EBEvent) {
    self.mObserversOf_boardRect.remove (inObserver)
    if let object = self.propval {
      object.boardRect_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardWidth
  //····················································································································

  private var mObserversOf_boardWidth = EBWeakEventSet ()

  //····················································································································

  var boardWidth_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardWidth_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardWidth (_ inObserver : EBEvent) {
    self.mObserversOf_boardWidth.insert (inObserver)
    if let object = self.propval {
      object.boardWidth_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardWidth (_ inObserver : EBEvent) {
    self.mObserversOf_boardWidth.remove (inObserver)
    if let object = self.propval {
      object.boardWidth_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: boardWidthUnit
  //····················································································································

  private var mObserversOf_boardWidthUnit = EBWeakEventSet ()

  //····················································································································

  var boardWidthUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.boardWidthUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_boardWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_boardWidthUnit.insert (inObserver)
    if let object = self.propval {
      object.boardWidthUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_boardWidthUnit (_ inObserver : EBEvent) {
    self.mObserversOf_boardWidthUnit.remove (inObserver)
    if let object = self.propval {
      object.boardWidthUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: generateGerberProductFile
  //····················································································································

  private var mObserversOf_generateGerberProductFile = EBWeakEventSet ()

  //····················································································································

  var generateGerberProductFile_property_selection : EBSelection <Bool?> {
    if let model = self.propval {
      switch (model.generateGerberProductFile_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_generateGerberProductFile (_ inObserver : EBEvent) {
    self.mObserversOf_generateGerberProductFile.insert (inObserver)
    if let object = self.propval {
      object.generateGerberProductFile_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_generateGerberProductFile (_ inObserver : EBEvent) {
    self.mObserversOf_generateGerberProductFile.remove (inObserver)
    if let object = self.propval {
      object.generateGerberProductFile_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: generatePDFProductFile
  //····················································································································

  private var mObserversOf_generatePDFProductFile = EBWeakEventSet ()

  //····················································································································

  var generatePDFProductFile_property_selection : EBSelection <Bool?> {
    if let model = self.propval {
      switch (model.generatePDFProductFile_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_generatePDFProductFile (_ inObserver : EBEvent) {
    self.mObserversOf_generatePDFProductFile.insert (inObserver)
    if let object = self.propval {
      object.generatePDFProductFile_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_generatePDFProductFile (_ inObserver : EBEvent) {
    self.mObserversOf_generatePDFProductFile.remove (inObserver)
    if let object = self.propval {
      object.generatePDFProductFile_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: generatedBoardArchiveFormat
  //····················································································································

  private var mObserversOf_generatedBoardArchiveFormat = EBWeakEventSet ()

  //····················································································································

  var generatedBoardArchiveFormat_property_selection : EBSelection <BoardArchiveFormat?> {
    if let model = self.propval {
      switch (model.generatedBoardArchiveFormat_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_generatedBoardArchiveFormat (_ inObserver : EBEvent) {
    self.mObserversOf_generatedBoardArchiveFormat.insert (inObserver)
    if let object = self.propval {
      object.generatedBoardArchiveFormat_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_generatedBoardArchiveFormat (_ inObserver : EBEvent) {
    self.mObserversOf_generatedBoardArchiveFormat.remove (inObserver)
    if let object = self.propval {
      object.generatedBoardArchiveFormat_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: modelNames
  //····················································································································

  private var mObserversOf_modelNames = EBWeakEventSet ()

  //····················································································································

  var modelNames_property_selection : EBSelection <StringTagArray?> {
    if let model = self.propval {
      switch (model.modelNames_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_modelNames (_ inObserver : EBEvent) {
    self.mObserversOf_modelNames.insert (inObserver)
    if let object = self.propval {
      object.modelNames_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_modelNames (_ inObserver : EBEvent) {
    self.mObserversOf_modelNames.remove (inObserver)
    if let object = self.propval {
      object.modelNames_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: overlapingArrangment
  //····················································································································

  private var mObserversOf_overlapingArrangment = EBWeakEventSet ()

  //····················································································································

  var overlapingArrangment_property_selection : EBSelection <Bool?> {
    if let model = self.propval {
      switch (model.overlapingArrangment_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_overlapingArrangment (_ inObserver : EBEvent) {
    self.mObserversOf_overlapingArrangment.insert (inObserver)
    if let object = self.propval {
      object.overlapingArrangment_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_overlapingArrangment (_ inObserver : EBEvent) {
    self.mObserversOf_overlapingArrangment.remove (inObserver)
    if let object = self.propval {
      object.overlapingArrangment_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: selectedBoardXUnit
  //····················································································································

  private var mObserversOf_selectedBoardXUnit = EBWeakEventSet ()

  //····················································································································

  var selectedBoardXUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.selectedBoardXUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_selectedBoardXUnit (_ inObserver : EBEvent) {
    self.mObserversOf_selectedBoardXUnit.insert (inObserver)
    if let object = self.propval {
      object.selectedBoardXUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_selectedBoardXUnit (_ inObserver : EBEvent) {
    self.mObserversOf_selectedBoardXUnit.remove (inObserver)
    if let object = self.propval {
      object.selectedBoardXUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: selectedBoardYUnit
  //····················································································································

  private var mObserversOf_selectedBoardYUnit = EBWeakEventSet ()

  //····················································································································

  var selectedBoardYUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.selectedBoardYUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_selectedBoardYUnit (_ inObserver : EBEvent) {
    self.mObserversOf_selectedBoardYUnit.insert (inObserver)
    if let object = self.propval {
      object.selectedBoardYUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_selectedBoardYUnit (_ inObserver : EBEvent) {
    self.mObserversOf_selectedBoardYUnit.remove (inObserver)
    if let object = self.propval {
      object.selectedBoardYUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: selectedPageIndex
  //····················································································································

  private var mObserversOf_selectedPageIndex = EBWeakEventSet ()

  //····················································································································

  var selectedPageIndex_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.selectedPageIndex_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_selectedPageIndex (_ inObserver : EBEvent) {
    self.mObserversOf_selectedPageIndex.insert (inObserver)
    if let object = self.propval {
      object.selectedPageIndex_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_selectedPageIndex (_ inObserver : EBEvent) {
    self.mObserversOf_selectedPageIndex.remove (inObserver)
    if let object = self.propval {
      object.selectedPageIndex_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: shiftArrowMagnitude
  //····················································································································

  private var mObserversOf_shiftArrowMagnitude = EBWeakEventSet ()

  //····················································································································

  var shiftArrowMagnitude_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.shiftArrowMagnitude_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_shiftArrowMagnitude (_ inObserver : EBEvent) {
    self.mObserversOf_shiftArrowMagnitude.insert (inObserver)
    if let object = self.propval {
      object.shiftArrowMagnitude_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_shiftArrowMagnitude (_ inObserver : EBEvent) {
    self.mObserversOf_shiftArrowMagnitude.remove (inObserver)
    if let object = self.propval {
      object.shiftArrowMagnitude_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: shiftArrowMagnitudeUnit
  //····················································································································

  private var mObserversOf_shiftArrowMagnitudeUnit = EBWeakEventSet ()

  //····················································································································

  var shiftArrowMagnitudeUnit_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.shiftArrowMagnitudeUnit_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_shiftArrowMagnitudeUnit (_ inObserver : EBEvent) {
    self.mObserversOf_shiftArrowMagnitudeUnit.insert (inObserver)
    if let object = self.propval {
      object.shiftArrowMagnitudeUnit_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_shiftArrowMagnitudeUnit (_ inObserver : EBEvent) {
    self.mObserversOf_shiftArrowMagnitudeUnit.remove (inObserver)
    if let object = self.propval {
      object.shiftArrowMagnitudeUnit_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································
  //   Observable atomic property: zoom
  //····················································································································

  private var mObserversOf_zoom = EBWeakEventSet ()

  //····················································································································

  var zoom_property_selection : EBSelection <Int?> {
    if let model = self.propval {
      switch (model.zoom_property_selection) {
      case .empty :
        return .empty
      case .multiple :
        return .multiple
      case .single (let v) :
        return .single (v)
      }
    }else{
      return .single (nil)
    }
  }

  //····················································································································

  final func addEBObserverOf_zoom (_ inObserver : EBEvent) {
    self.mObserversOf_zoom.insert (inObserver)
    if let object = self.propval {
      object.zoom_property.addEBObserver (inObserver)
    }
  }

  //····················································································································

  final func removeEBObserverOf_zoom (_ inObserver : EBEvent) {
    self.mObserversOf_zoom.remove (inObserver)
    if let object = self.propval {
      object.zoom_property.removeEBObserver (inObserver)
    }
  }

  //····················································································································

}
#endif

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
