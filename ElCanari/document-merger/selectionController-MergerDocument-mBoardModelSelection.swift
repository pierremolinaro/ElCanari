//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    SelectionController_MergerDocument_mBoardModelSelection                                                          *
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(SelectionController_MergerDocument_mBoardModelSelection)
final class SelectionController_MergerDocument_mBoardModelSelection : EBObject {
  private var mModel : ReadOnlyArrayOf_BoardModel?

  //····················································································································
  //   SELECTION OBSERVABLE PROPERTIES
  //····················································································································

  var artworkName_property = EBPropertyProxy_String ()

  var artworkName_property_selection : EBSelection <String> {
    get {
      return self.artworkName_property.prop
    }
  }
  var backComponentNameDisplay_property = EBTransientProperty_CALayer ()

  var backComponentNameDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backComponentNameDisplay_property.prop
    }
  }
  var backComponentNameSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentNameSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentNameSegments_property.prop
    }
  }
  var backComponentNamesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backComponentNamesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backComponentNamesBezierPaths_property.prop
    }
  }
  var backComponentValueDisplay_property = EBTransientProperty_CALayer ()

  var backComponentValueDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backComponentValueDisplay_property.prop
    }
  }
  var backComponentValueSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentValueSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentValueSegments_property.prop
    }
  }
  var backComponentValuesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backComponentValuesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backComponentValuesBezierPaths_property.prop
    }
  }
  var backLayoutTextsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backLayoutTextsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backLayoutTextsBezierPaths_property.prop
    }
  }
  var backLayoutTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var backLayoutTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backLayoutTextsLayerDisplay_property.prop
    }
  }
  var backLayoutTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLayoutTextsSegments_property.prop
    }
  }
  var backLegendLinesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backLegendLinesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backLegendLinesBezierPaths_property.prop
    }
  }
  var backLegendLinesLayerDisplay_property = EBTransientProperty_CALayer ()

  var backLegendLinesLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backLegendLinesLayerDisplay_property.prop
    }
  }
  var backLegendLinesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLegendLinesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLegendLinesSegments_property.prop
    }
  }
  var backLegendTextsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backLegendTextsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backLegendTextsBezierPaths_property.prop
    }
  }
  var backLegendTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var backLegendTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backLegendTextsLayerDisplay_property.prop
    }
  }
  var backLegendTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLegendTextsSegments_property.prop
    }
  }
  var backPackagesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backPackagesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backPackagesBezierPaths_property.prop
    }
  }
  var backPackagesDisplay_property = EBTransientProperty_CALayer ()

  var backPackagesDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backPackagesDisplay_property.prop
    }
  }
  var backPackagesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backPackagesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backPackagesSegments_property.prop
    }
  }
  var backPads_property = EBTransientProperty_MergerPadArray ()

  var backPads_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.backPads_property.prop
    }
  }
  var backPadsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backPadsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backPadsBezierPaths_property.prop
    }
  }
  var backPadsDisplay_property = EBTransientProperty_CALayer ()

  var backPadsDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backPadsDisplay_property.prop
    }
  }
  var backTrackSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backTrackSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backTrackSegments_property.prop
    }
  }
  var backTracksBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var backTracksBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.backTracksBezierPaths_property.prop
    }
  }
  var backTracksDisplay_property = EBTransientProperty_CALayer ()

  var backTracksDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backTracksDisplay_property.prop
    }
  }
  var backgroundLayerDisplay_property = EBTransientProperty_CALayer ()

  var backgroundLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backgroundLayerDisplay_property.prop
    }
  }
  var boardLimits_property = EBTransientProperty_MergerBoardLimits ()

  var boardLimits_property_selection : EBSelection <MergerBoardLimits> {
    get {
      return self.boardLimits_property.prop
    }
  }
  var boardLimitsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var boardLimitsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.boardLimitsBezierPaths_property.prop
    }
  }
  var boardLimitsDisplay_property = EBTransientProperty_CALayer ()

  var boardLimitsDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.boardLimitsDisplay_property.prop
    }
  }
  var frontComponentNameDisplay_property = EBTransientProperty_CALayer ()

  var frontComponentNameDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontComponentNameDisplay_property.prop
    }
  }
  var frontComponentNameSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentNameSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentNameSegments_property.prop
    }
  }
  var frontComponentNamesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontComponentNamesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontComponentNamesBezierPaths_property.prop
    }
  }
  var frontComponentValueDisplay_property = EBTransientProperty_CALayer ()

  var frontComponentValueDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontComponentValueDisplay_property.prop
    }
  }
  var frontComponentValueSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentValueSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentValueSegments_property.prop
    }
  }
  var frontComponentValuesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontComponentValuesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontComponentValuesBezierPaths_property.prop
    }
  }
  var frontLayoutTextsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontLayoutTextsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontLayoutTextsBezierPaths_property.prop
    }
  }
  var frontLayoutTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var frontLayoutTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLayoutTextsLayerDisplay_property.prop
    }
  }
  var frontLayoutTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLayoutTextsSegments_property.prop
    }
  }
  var frontLegendLinesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontLegendLinesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontLegendLinesBezierPaths_property.prop
    }
  }
  var frontLegendLinesLayerDisplay_property = EBTransientProperty_CALayer ()

  var frontLegendLinesLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLegendLinesLayerDisplay_property.prop
    }
  }
  var frontLegendLinesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLegendLinesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLegendLinesSegments_property.prop
    }
  }
  var frontLegendTextsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontLegendTextsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontLegendTextsBezierPaths_property.prop
    }
  }
  var frontLegendTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var frontLegendTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLegendTextsLayerDisplay_property.prop
    }
  }
  var frontLegendTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLegendTextsSegments_property.prop
    }
  }
  var frontPackagesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontPackagesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontPackagesBezierPaths_property.prop
    }
  }
  var frontPackagesDisplay_property = EBTransientProperty_CALayer ()

  var frontPackagesDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontPackagesDisplay_property.prop
    }
  }
  var frontPackagesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontPackagesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontPackagesSegments_property.prop
    }
  }
  var frontPads_property = EBTransientProperty_MergerPadArray ()

  var frontPads_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.frontPads_property.prop
    }
  }
  var frontPadsBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontPadsBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontPadsBezierPaths_property.prop
    }
  }
  var frontPadsDisplay_property = EBTransientProperty_CALayer ()

  var frontPadsDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontPadsDisplay_property.prop
    }
  }
  var frontTrackSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontTrackSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontTrackSegments_property.prop
    }
  }
  var frontTracksBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var frontTracksBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.frontTracksBezierPaths_property.prop
    }
  }
  var frontTracksDisplay_property = EBTransientProperty_CALayer ()

  var frontTracksDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontTracksDisplay_property.prop
    }
  }
  var holeLayerDisplay_property = EBTransientProperty_CALayer ()

  var holeLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.holeLayerDisplay_property.prop
    }
  }
  var holes_property = EBTransientProperty_MergerHoleArray ()

  var holes_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.holes_property.prop
    }
  }
  var holesBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var holesBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.holesBezierPaths_property.prop
    }
  }
  var imageForInstances_property = EBTransientProperty_EBShapes ()

  var imageForInstances_property_selection : EBSelection <EBShapes> {
    get {
      return self.imageForInstances_property.prop
    }
  }
  var instanceCount_property = EBTransientProperty_Int ()

  var instanceCount_property_selection : EBSelection <Int> {
    get {
      return self.instanceCount_property.prop
    }
  }
  var modelHeight_property = EBPropertyProxy_Int ()

  var modelHeight_property_selection : EBSelection <Int> {
    get {
      return self.modelHeight_property.prop
    }
  }
  var modelHeightUnit_property = EBPropertyProxy_Int ()

  var modelHeightUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelHeightUnit_property.prop
    }
  }
  var modelLayerDisplay_property = EBTransientProperty_CALayer ()

  var modelLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.modelLayerDisplay_property.prop
    }
  }
  var modelLimitWidth_property = EBPropertyProxy_Int ()

  var modelLimitWidth_property_selection : EBSelection <Int> {
    get {
      return self.modelLimitWidth_property.prop
    }
  }
  var modelLimitWidthUnit_property = EBPropertyProxy_Int ()

  var modelLimitWidthUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelLimitWidthUnit_property.prop
    }
  }
  var modelWidth_property = EBPropertyProxy_Int ()

  var modelWidth_property_selection : EBSelection <Int> {
    get {
      return self.modelWidth_property.prop
    }
  }
  var modelWidthUnit_property = EBPropertyProxy_Int ()

  var modelWidthUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelWidthUnit_property.prop
    }
  }
  var name_property = EBPropertyProxy_String ()

  var name_property_selection : EBSelection <String> {
    get {
      return self.name_property.prop
    }
  }
  var padsHoles_property = EBTransientProperty_MergerHoleArray ()

  var padsHoles_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.padsHoles_property.prop
    }
  }
  var viaLayerDisplay_property = EBTransientProperty_CALayer ()

  var viaLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.viaLayerDisplay_property.prop
    }
  }
  var viaShapes_property = EBTransientProperty_MergerViaShapeArray ()

  var viaShapes_property_selection : EBSelection <MergerViaShapeArray> {
    get {
      return self.viaShapes_property.prop
    }
  }
  var viasBezierPaths_property = EBTransientProperty_BezierPathArray ()

  var viasBezierPaths_property_selection : EBSelection <BezierPathArray> {
    get {
      return self.viasBezierPaths_property.prop
    }
  }
  var viasHoles_property = EBTransientProperty_MergerHoleArray ()

  var viasHoles_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.viasHoles_property.prop
    }
  }
  var zoom_property = EBPropertyProxy_Int ()

  var zoom_property_selection : EBSelection <Int> {
    get {
      return self.zoom_property.prop
    }
  }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_BoardModel, file:String, line:Int) {
    mModel = model
    bind_property_artworkName (model: model)
    bind_property_backComponentNameDisplay (model: model)
    bind_property_backComponentNameSegments (model: model)
    bind_property_backComponentNamesBezierPaths (model: model)
    bind_property_backComponentValueDisplay (model: model)
    bind_property_backComponentValueSegments (model: model)
    bind_property_backComponentValuesBezierPaths (model: model)
    bind_property_backLayoutTextsBezierPaths (model: model)
    bind_property_backLayoutTextsLayerDisplay (model: model)
    bind_property_backLayoutTextsSegments (model: model)
    bind_property_backLegendLinesBezierPaths (model: model)
    bind_property_backLegendLinesLayerDisplay (model: model)
    bind_property_backLegendLinesSegments (model: model)
    bind_property_backLegendTextsBezierPaths (model: model)
    bind_property_backLegendTextsLayerDisplay (model: model)
    bind_property_backLegendTextsSegments (model: model)
    bind_property_backPackagesBezierPaths (model: model)
    bind_property_backPackagesDisplay (model: model)
    bind_property_backPackagesSegments (model: model)
    bind_property_backPads (model: model)
    bind_property_backPadsBezierPaths (model: model)
    bind_property_backPadsDisplay (model: model)
    bind_property_backTrackSegments (model: model)
    bind_property_backTracksBezierPaths (model: model)
    bind_property_backTracksDisplay (model: model)
    bind_property_backgroundLayerDisplay (model: model)
    bind_property_boardLimits (model: model)
    bind_property_boardLimitsBezierPaths (model: model)
    bind_property_boardLimitsDisplay (model: model)
    bind_property_frontComponentNameDisplay (model: model)
    bind_property_frontComponentNameSegments (model: model)
    bind_property_frontComponentNamesBezierPaths (model: model)
    bind_property_frontComponentValueDisplay (model: model)
    bind_property_frontComponentValueSegments (model: model)
    bind_property_frontComponentValuesBezierPaths (model: model)
    bind_property_frontLayoutTextsBezierPaths (model: model)
    bind_property_frontLayoutTextsLayerDisplay (model: model)
    bind_property_frontLayoutTextsSegments (model: model)
    bind_property_frontLegendLinesBezierPaths (model: model)
    bind_property_frontLegendLinesLayerDisplay (model: model)
    bind_property_frontLegendLinesSegments (model: model)
    bind_property_frontLegendTextsBezierPaths (model: model)
    bind_property_frontLegendTextsLayerDisplay (model: model)
    bind_property_frontLegendTextsSegments (model: model)
    bind_property_frontPackagesBezierPaths (model: model)
    bind_property_frontPackagesDisplay (model: model)
    bind_property_frontPackagesSegments (model: model)
    bind_property_frontPads (model: model)
    bind_property_frontPadsBezierPaths (model: model)
    bind_property_frontPadsDisplay (model: model)
    bind_property_frontTrackSegments (model: model)
    bind_property_frontTracksBezierPaths (model: model)
    bind_property_frontTracksDisplay (model: model)
    bind_property_holeLayerDisplay (model: model)
    bind_property_holes (model: model)
    bind_property_holesBezierPaths (model: model)
    bind_property_imageForInstances (model: model)
    bind_property_instanceCount (model: model)
    bind_property_modelHeight (model: model)
    bind_property_modelHeightUnit (model: model)
    bind_property_modelLayerDisplay (model: model)
    bind_property_modelLimitWidth (model: model)
    bind_property_modelLimitWidthUnit (model: model)
    bind_property_modelWidth (model: model)
    bind_property_modelWidthUnit (model: model)
    bind_property_name (model: model)
    bind_property_padsHoles (model: model)
    bind_property_viaLayerDisplay (model: model)
    bind_property_viaShapes (model: model)
    bind_property_viasBezierPaths (model: model)
    bind_property_viasHoles (model: model)
    bind_property_zoom (model: model)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize ())
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame:thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (mEasyBindingsObjectIndex) + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_MergerDocument_mBoardModelSelection.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
    mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame:r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "artworkName",
      idx:self.artworkName_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.artworkName_property.mObserverExplorer,
      valueExplorer:&self.artworkName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelHeight",
      idx:self.modelHeight_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelHeight_property.mObserverExplorer,
      valueExplorer:&self.modelHeight_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelHeightUnit",
      idx:self.modelHeightUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelHeightUnit_property.mObserverExplorer,
      valueExplorer:&self.modelHeightUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelLimitWidth",
      idx:self.modelLimitWidth_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelLimitWidth_property.mObserverExplorer,
      valueExplorer:&self.modelLimitWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelLimitWidthUnit",
      idx:self.modelLimitWidthUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelLimitWidthUnit_property.mObserverExplorer,
      valueExplorer:&self.modelLimitWidthUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelWidth",
      idx:self.modelWidth_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelWidth_property.mObserverExplorer,
      valueExplorer:&self.modelWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelWidthUnit",
      idx:self.modelWidthUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelWidthUnit_property.mObserverExplorer,
      valueExplorer:&self.modelWidthUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "name",
      idx:self.name_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.name_property.mObserverExplorer,
      valueExplorer:&self.name_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "zoom",
      idx:self.zoom_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.zoom_property.mObserverExplorer,
      valueExplorer:&self.zoom_property.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    view.frame = viewFrame
  //--- Set content size
    mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_MergerDocument_mBoardModelSelection.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (mEasyBindingsObjectIndex) + className
    mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    let sw = NSScrollView (frame:frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  func showObjectWindowFromExplorerButton (_ : Any) {
    if mExplorerWindow == nil {
      buildExplorerWindow ()
    }
    mExplorerWindow?.makeKeyAndOrderFront(nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  func deleteSelectionControllerWindowAction (_ : Any) {
    clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton!.target = nil
    mExplorerWindow?.orderOut (nil)
    mExplorerWindow = nil
  }

  //···················································································································*

  private final func bind_property_artworkName (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_artworkName (self.artworkName_property)
    self.artworkName_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.artworkName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.artworkName_property.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.artworkName_property.setProp (inValue)
          }
        }
      }
    }
    self.artworkName_property.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.artworkName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentNameDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backComponentNameDisplay (self.backComponentNameDisplay_property)
    self.backComponentNameDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentNameDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentNameSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backComponentNameSegments (self.backComponentNameSegments_property)
    self.backComponentNameSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentNameSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentNamesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backComponentNamesBezierPaths (self.backComponentNamesBezierPaths_property)
    self.backComponentNamesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentNamesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentValueDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backComponentValueDisplay (self.backComponentValueDisplay_property)
    self.backComponentValueDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentValueDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentValueSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backComponentValueSegments (self.backComponentValueSegments_property)
    self.backComponentValueSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentValueSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentValuesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backComponentValuesBezierPaths (self.backComponentValuesBezierPaths_property)
    self.backComponentValuesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentValuesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLayoutTextsBezierPaths (self.backLayoutTextsBezierPaths_property)
    self.backLayoutTextsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLayoutTextsLayerDisplay (self.backLayoutTextsLayerDisplay_property)
    self.backLayoutTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLayoutTextsSegments (self.backLayoutTextsSegments_property)
    self.backLayoutTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendLinesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLegendLinesBezierPaths (self.backLegendLinesBezierPaths_property)
    self.backLegendLinesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendLinesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendLinesLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLegendLinesLayerDisplay (self.backLegendLinesLayerDisplay_property)
    self.backLegendLinesLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendLinesLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendLinesSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLegendLinesSegments (self.backLegendLinesSegments_property)
    self.backLegendLinesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendLinesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLegendTextsBezierPaths (self.backLegendTextsBezierPaths_property)
    self.backLegendTextsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLegendTextsLayerDisplay (self.backLegendTextsLayerDisplay_property)
    self.backLegendTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backLegendTextsSegments (self.backLegendTextsSegments_property)
    self.backLegendTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPackagesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backPackagesBezierPaths (self.backPackagesBezierPaths_property)
    self.backPackagesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPackagesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPackagesDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backPackagesDisplay (self.backPackagesDisplay_property)
    self.backPackagesDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPackagesDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPackagesSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backPackagesSegments (self.backPackagesSegments_property)
    self.backPackagesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPackagesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPads (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backPads (self.backPads_property)
    self.backPads_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPads_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPadsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backPadsBezierPaths (self.backPadsBezierPaths_property)
    self.backPadsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPadsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPadsDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backPadsDisplay (self.backPadsDisplay_property)
    self.backPadsDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPadsDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backTrackSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backTrackSegments (self.backTrackSegments_property)
    self.backTrackSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backTrackSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backTracksBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backTracksBezierPaths (self.backTracksBezierPaths_property)
    self.backTracksBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backTracksBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backTracksDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backTracksDisplay (self.backTracksDisplay_property)
    self.backTracksDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backTracksDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backgroundLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_backgroundLayerDisplay (self.backgroundLayerDisplay_property)
    self.backgroundLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backgroundLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimits (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_boardLimits (self.boardLimits_property)
    self.boardLimits_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerBoardLimits> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimits_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimitsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_boardLimitsBezierPaths (self.boardLimitsBezierPaths_property)
    self.boardLimitsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimitsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimitsDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_boardLimitsDisplay (self.boardLimitsDisplay_property)
    self.boardLimitsDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimitsDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentNameDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontComponentNameDisplay (self.frontComponentNameDisplay_property)
    self.frontComponentNameDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentNameDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentNameSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontComponentNameSegments (self.frontComponentNameSegments_property)
    self.frontComponentNameSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentNameSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentNamesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontComponentNamesBezierPaths (self.frontComponentNamesBezierPaths_property)
    self.frontComponentNamesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentNamesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentValueDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontComponentValueDisplay (self.frontComponentValueDisplay_property)
    self.frontComponentValueDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentValueDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentValueSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontComponentValueSegments (self.frontComponentValueSegments_property)
    self.frontComponentValueSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentValueSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentValuesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontComponentValuesBezierPaths (self.frontComponentValuesBezierPaths_property)
    self.frontComponentValuesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentValuesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLayoutTextsBezierPaths (self.frontLayoutTextsBezierPaths_property)
    self.frontLayoutTextsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLayoutTextsLayerDisplay (self.frontLayoutTextsLayerDisplay_property)
    self.frontLayoutTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLayoutTextsSegments (self.frontLayoutTextsSegments_property)
    self.frontLayoutTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendLinesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLegendLinesBezierPaths (self.frontLegendLinesBezierPaths_property)
    self.frontLegendLinesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendLinesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendLinesLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLegendLinesLayerDisplay (self.frontLegendLinesLayerDisplay_property)
    self.frontLegendLinesLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendLinesLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendLinesSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLegendLinesSegments (self.frontLegendLinesSegments_property)
    self.frontLegendLinesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendLinesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLegendTextsBezierPaths (self.frontLegendTextsBezierPaths_property)
    self.frontLegendTextsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLegendTextsLayerDisplay (self.frontLegendTextsLayerDisplay_property)
    self.frontLegendTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontLegendTextsSegments (self.frontLegendTextsSegments_property)
    self.frontLegendTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPackagesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontPackagesBezierPaths (self.frontPackagesBezierPaths_property)
    self.frontPackagesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPackagesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPackagesDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontPackagesDisplay (self.frontPackagesDisplay_property)
    self.frontPackagesDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPackagesDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPackagesSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontPackagesSegments (self.frontPackagesSegments_property)
    self.frontPackagesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPackagesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPads (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontPads (self.frontPads_property)
    self.frontPads_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPads_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPadsBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontPadsBezierPaths (self.frontPadsBezierPaths_property)
    self.frontPadsBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPadsBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPadsDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontPadsDisplay (self.frontPadsDisplay_property)
    self.frontPadsDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPadsDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontTrackSegments (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontTrackSegments (self.frontTrackSegments_property)
    self.frontTrackSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontTrackSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontTracksBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontTracksBezierPaths (self.frontTracksBezierPaths_property)
    self.frontTracksBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontTracksBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontTracksDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_frontTracksDisplay (self.frontTracksDisplay_property)
    self.frontTracksDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontTracksDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_holeLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_holeLayerDisplay (self.holeLayerDisplay_property)
    self.holeLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.holeLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_holes (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_holes (self.holes_property)
    self.holes_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.holes_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_holesBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_holesBezierPaths (self.holesBezierPaths_property)
    self.holesBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.holesBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_imageForInstances (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_imageForInstances (self.imageForInstances_property)
    self.imageForInstances_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<EBShapes> ()
          var isMultipleSelection = false
          for object in v {
            switch object.imageForInstances_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_instanceCount (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_instanceCount (self.instanceCount_property)
    self.instanceCount_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.instanceCount_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelHeight (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelHeight (self.modelHeight_property)
    self.modelHeight_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelHeight_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelHeight_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelHeight_property.setProp (inValue)
          }
        }
      }
    }
    self.modelHeight_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelHeight_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelHeightUnit (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelHeightUnit (self.modelHeightUnit_property)
    self.modelHeightUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelHeightUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelHeightUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelHeightUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelHeightUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelHeightUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelLayerDisplay (self.modelLayerDisplay_property)
    self.modelLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelLimitWidth (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelLimitWidth (self.modelLimitWidth_property)
    self.modelLimitWidth_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelLimitWidth_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelLimitWidth_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelLimitWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.modelLimitWidth_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelLimitWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelLimitWidthUnit (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelLimitWidthUnit (self.modelLimitWidthUnit_property)
    self.modelLimitWidthUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelLimitWidthUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelLimitWidthUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelLimitWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelLimitWidthUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelLimitWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelWidth (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelWidth (self.modelWidth_property)
    self.modelWidth_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelWidth_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelWidth_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.modelWidth_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelWidthUnit (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_modelWidthUnit (self.modelWidthUnit_property)
    self.modelWidthUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelWidthUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelWidthUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelWidthUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_name (self.name_property)
    self.name_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.name_property.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.name_property.setProp (inValue)
          }
        }
      }
    }
    self.name_property.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.name_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padsHoles (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_padsHoles (self.padsHoles_property)
    self.padsHoles_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padsHoles_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viaLayerDisplay (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_viaLayerDisplay (self.viaLayerDisplay_property)
    self.viaLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viaLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viaShapes (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_viaShapes (self.viaShapes_property)
    self.viaShapes_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerViaShapeArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viaShapes_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viasBezierPaths (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_viasBezierPaths (self.viasBezierPaths_property)
    self.viasBezierPaths_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<BezierPathArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viasBezierPaths_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viasHoles (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_viasHoles (self.viasHoles_property)
    self.viasHoles_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viasHoles_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_zoom (model : ReadOnlyArrayOf_BoardModel) {
    model.addEBObserverOf_zoom (self.zoom_property)
    self.zoom_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.zoom_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.zoom_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.zoom_property.setProp (inValue)
          }
        }
      }
    }
    self.zoom_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.zoom_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }



  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
  //--- artworkName
    self.artworkName_property.readModelFunction = nil 
    self.artworkName_property.writeModelFunction = nil 
    self.artworkName_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_artworkName (self.artworkName_property)
  //--- backComponentNameDisplay
    self.backComponentNameDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentNameDisplay (self.backComponentNameDisplay_property)
  //--- backComponentNameSegments
    self.backComponentNameSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentNameSegments (self.backComponentNameSegments_property)
  //--- backComponentNamesBezierPaths
    self.backComponentNamesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentNamesBezierPaths (self.backComponentNamesBezierPaths_property)
  //--- backComponentValueDisplay
    self.backComponentValueDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentValueDisplay (self.backComponentValueDisplay_property)
  //--- backComponentValueSegments
    self.backComponentValueSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentValueSegments (self.backComponentValueSegments_property)
  //--- backComponentValuesBezierPaths
    self.backComponentValuesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentValuesBezierPaths (self.backComponentValuesBezierPaths_property)
  //--- backLayoutTextsBezierPaths
    self.backLayoutTextsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsBezierPaths (self.backLayoutTextsBezierPaths_property)
  //--- backLayoutTextsLayerDisplay
    self.backLayoutTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsLayerDisplay (self.backLayoutTextsLayerDisplay_property)
  //--- backLayoutTextsSegments
    self.backLayoutTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsSegments (self.backLayoutTextsSegments_property)
  //--- backLegendLinesBezierPaths
    self.backLegendLinesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendLinesBezierPaths (self.backLegendLinesBezierPaths_property)
  //--- backLegendLinesLayerDisplay
    self.backLegendLinesLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendLinesLayerDisplay (self.backLegendLinesLayerDisplay_property)
  //--- backLegendLinesSegments
    self.backLegendLinesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendLinesSegments (self.backLegendLinesSegments_property)
  //--- backLegendTextsBezierPaths
    self.backLegendTextsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsBezierPaths (self.backLegendTextsBezierPaths_property)
  //--- backLegendTextsLayerDisplay
    self.backLegendTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsLayerDisplay (self.backLegendTextsLayerDisplay_property)
  //--- backLegendTextsSegments
    self.backLegendTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsSegments (self.backLegendTextsSegments_property)
  //--- backPackagesBezierPaths
    self.backPackagesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPackagesBezierPaths (self.backPackagesBezierPaths_property)
  //--- backPackagesDisplay
    self.backPackagesDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPackagesDisplay (self.backPackagesDisplay_property)
  //--- backPackagesSegments
    self.backPackagesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPackagesSegments (self.backPackagesSegments_property)
  //--- backPads
    self.backPads_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPads (self.backPads_property)
  //--- backPadsBezierPaths
    self.backPadsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPadsBezierPaths (self.backPadsBezierPaths_property)
  //--- backPadsDisplay
    self.backPadsDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPadsDisplay (self.backPadsDisplay_property)
  //--- backTrackSegments
    self.backTrackSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backTrackSegments (self.backTrackSegments_property)
  //--- backTracksBezierPaths
    self.backTracksBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backTracksBezierPaths (self.backTracksBezierPaths_property)
  //--- backTracksDisplay
    self.backTracksDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backTracksDisplay (self.backTracksDisplay_property)
  //--- backgroundLayerDisplay
    self.backgroundLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backgroundLayerDisplay (self.backgroundLayerDisplay_property)
  //--- boardLimits
    self.boardLimits_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimits (self.boardLimits_property)
  //--- boardLimitsBezierPaths
    self.boardLimitsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimitsBezierPaths (self.boardLimitsBezierPaths_property)
  //--- boardLimitsDisplay
    self.boardLimitsDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimitsDisplay (self.boardLimitsDisplay_property)
  //--- frontComponentNameDisplay
    self.frontComponentNameDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentNameDisplay (self.frontComponentNameDisplay_property)
  //--- frontComponentNameSegments
    self.frontComponentNameSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentNameSegments (self.frontComponentNameSegments_property)
  //--- frontComponentNamesBezierPaths
    self.frontComponentNamesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentNamesBezierPaths (self.frontComponentNamesBezierPaths_property)
  //--- frontComponentValueDisplay
    self.frontComponentValueDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentValueDisplay (self.frontComponentValueDisplay_property)
  //--- frontComponentValueSegments
    self.frontComponentValueSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentValueSegments (self.frontComponentValueSegments_property)
  //--- frontComponentValuesBezierPaths
    self.frontComponentValuesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentValuesBezierPaths (self.frontComponentValuesBezierPaths_property)
  //--- frontLayoutTextsBezierPaths
    self.frontLayoutTextsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsBezierPaths (self.frontLayoutTextsBezierPaths_property)
  //--- frontLayoutTextsLayerDisplay
    self.frontLayoutTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsLayerDisplay (self.frontLayoutTextsLayerDisplay_property)
  //--- frontLayoutTextsSegments
    self.frontLayoutTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsSegments (self.frontLayoutTextsSegments_property)
  //--- frontLegendLinesBezierPaths
    self.frontLegendLinesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendLinesBezierPaths (self.frontLegendLinesBezierPaths_property)
  //--- frontLegendLinesLayerDisplay
    self.frontLegendLinesLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendLinesLayerDisplay (self.frontLegendLinesLayerDisplay_property)
  //--- frontLegendLinesSegments
    self.frontLegendLinesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendLinesSegments (self.frontLegendLinesSegments_property)
  //--- frontLegendTextsBezierPaths
    self.frontLegendTextsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsBezierPaths (self.frontLegendTextsBezierPaths_property)
  //--- frontLegendTextsLayerDisplay
    self.frontLegendTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsLayerDisplay (self.frontLegendTextsLayerDisplay_property)
  //--- frontLegendTextsSegments
    self.frontLegendTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsSegments (self.frontLegendTextsSegments_property)
  //--- frontPackagesBezierPaths
    self.frontPackagesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPackagesBezierPaths (self.frontPackagesBezierPaths_property)
  //--- frontPackagesDisplay
    self.frontPackagesDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPackagesDisplay (self.frontPackagesDisplay_property)
  //--- frontPackagesSegments
    self.frontPackagesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPackagesSegments (self.frontPackagesSegments_property)
  //--- frontPads
    self.frontPads_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPads (self.frontPads_property)
  //--- frontPadsBezierPaths
    self.frontPadsBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPadsBezierPaths (self.frontPadsBezierPaths_property)
  //--- frontPadsDisplay
    self.frontPadsDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPadsDisplay (self.frontPadsDisplay_property)
  //--- frontTrackSegments
    self.frontTrackSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontTrackSegments (self.frontTrackSegments_property)
  //--- frontTracksBezierPaths
    self.frontTracksBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontTracksBezierPaths (self.frontTracksBezierPaths_property)
  //--- frontTracksDisplay
    self.frontTracksDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontTracksDisplay (self.frontTracksDisplay_property)
  //--- holeLayerDisplay
    self.holeLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_holeLayerDisplay (self.holeLayerDisplay_property)
  //--- holes
    self.holes_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_holes (self.holes_property)
  //--- holesBezierPaths
    self.holesBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_holesBezierPaths (self.holesBezierPaths_property)
  //--- imageForInstances
    self.imageForInstances_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_imageForInstances (self.imageForInstances_property)
  //--- instanceCount
    self.instanceCount_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_instanceCount (self.instanceCount_property)
  //--- modelHeight
    self.modelHeight_property.readModelFunction = nil 
    self.modelHeight_property.writeModelFunction = nil 
    self.modelHeight_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelHeight (self.modelHeight_property)
  //--- modelHeightUnit
    self.modelHeightUnit_property.readModelFunction = nil 
    self.modelHeightUnit_property.writeModelFunction = nil 
    self.modelHeightUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelHeightUnit (self.modelHeightUnit_property)
  //--- modelLayerDisplay
    self.modelLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelLayerDisplay (self.modelLayerDisplay_property)
  //--- modelLimitWidth
    self.modelLimitWidth_property.readModelFunction = nil 
    self.modelLimitWidth_property.writeModelFunction = nil 
    self.modelLimitWidth_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelLimitWidth (self.modelLimitWidth_property)
  //--- modelLimitWidthUnit
    self.modelLimitWidthUnit_property.readModelFunction = nil 
    self.modelLimitWidthUnit_property.writeModelFunction = nil 
    self.modelLimitWidthUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelLimitWidthUnit (self.modelLimitWidthUnit_property)
  //--- modelWidth
    self.modelWidth_property.readModelFunction = nil 
    self.modelWidth_property.writeModelFunction = nil 
    self.modelWidth_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelWidth (self.modelWidth_property)
  //--- modelWidthUnit
    self.modelWidthUnit_property.readModelFunction = nil 
    self.modelWidthUnit_property.writeModelFunction = nil 
    self.modelWidthUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelWidthUnit (self.modelWidthUnit_property)
  //--- name
    self.name_property.readModelFunction = nil 
    self.name_property.writeModelFunction = nil 
    self.name_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_name (self.name_property)
  //--- padsHoles
    self.padsHoles_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_padsHoles (self.padsHoles_property)
  //--- viaLayerDisplay
    self.viaLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viaLayerDisplay (self.viaLayerDisplay_property)
  //--- viaShapes
    self.viaShapes_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viaShapes (self.viaShapes_property)
  //--- viasBezierPaths
    self.viasBezierPaths_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viasBezierPaths (self.viasBezierPaths_property)
  //--- viasHoles
    self.viasHoles_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viasHoles (self.viasHoles_property)
  //--- zoom
    self.zoom_property.readModelFunction = nil 
    self.zoom_property.writeModelFunction = nil 
    self.zoom_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_zoom (self.zoom_property)
  //---
    mModel = nil    
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

