//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    SelectionController_PMMergerDocument_mBoardModelSelection                                                        *
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(SelectionController_PMMergerDocument_mBoardModelSelection)
final class SelectionController_PMMergerDocument_mBoardModelSelection : EBObject {
  private var mModel : ReadOnlyArrayOf_BoardModelEntity?

  //····················································································································
  //   SELECTION OBSERVABLE PROPERTIES
  //····················································································································

  var artworkName_property = EBPropertyProxy_String ()

  var artworkName_property_selection : EBSelection <String> {
    get {
      return self.artworkName_property.prop
    }
  }
  var backComponentNameSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentNameSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentNameSegments_property.prop
    }
  }
  var backComponentNameSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentNameSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentNameSegmentsForDisplay_property.prop
    }
  }
  var backComponentValueSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentValueSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentValueSegments_property.prop
    }
  }
  var backComponentValuesForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentValuesForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentValuesForDisplay_property.prop
    }
  }
  var backLayoutTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLayoutTextsSegments_property.prop
    }
  }
  var backLayoutTextsSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var backLayoutTextsSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLayoutTextsSegmentsForDisplay_property.prop
    }
  }
  var backLegendTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLegendTextsSegments_property.prop
    }
  }
  var backLegendTextsSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var backLegendTextsSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLegendTextsSegmentsForDisplay_property.prop
    }
  }
  var backPackagesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backPackagesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backPackagesSegments_property.prop
    }
  }
  var backPackagesSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var backPackagesSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backPackagesSegmentsForDisplay_property.prop
    }
  }
  var backPads_property = EBTransientProperty_MergerPadArray ()

  var backPads_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.backPads_property.prop
    }
  }
  var backPadsForDisplay_property = EBTransientProperty_MergerPadArray ()

  var backPadsForDisplay_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.backPadsForDisplay_property.prop
    }
  }
  var backTrackSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backTrackSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backTrackSegments_property.prop
    }
  }
  var backTrackSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var backTrackSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backTrackSegmentsForDisplay_property.prop
    }
  }
  var boardLimitWidth_property = EBPropertyProxy_Int ()

  var boardLimitWidth_property_selection : EBSelection <Int> {
    get {
      return self.boardLimitWidth_property.prop
    }
  }
  var boardLimitWidthUnit_property = EBPropertyProxy_Int ()

  var boardLimitWidthUnit_property_selection : EBSelection <Int> {
    get {
      return self.boardLimitWidthUnit_property.prop
    }
  }
  var boardLimits_property = EBTransientProperty_MergerBoardLimits ()

  var boardLimits_property_selection : EBSelection <MergerBoardLimits> {
    get {
      return self.boardLimits_property.prop
    }
  }
  var frontComponentNameSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentNameSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentNameSegments_property.prop
    }
  }
  var frontComponentNameSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentNameSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentNameSegmentsForDisplay_property.prop
    }
  }
  var frontComponentValueSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentValueSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentValueSegments_property.prop
    }
  }
  var frontComponentValuesForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentValuesForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentValuesForDisplay_property.prop
    }
  }
  var frontLayoutTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLayoutTextsSegments_property.prop
    }
  }
  var frontLayoutTextsSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var frontLayoutTextsSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLayoutTextsSegmentsForDisplay_property.prop
    }
  }
  var frontLegendTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLegendTextsSegments_property.prop
    }
  }
  var frontLegendTextsSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var frontLegendTextsSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLegendTextsSegmentsForDisplay_property.prop
    }
  }
  var frontPackagesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontPackagesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontPackagesSegments_property.prop
    }
  }
  var frontPackagesSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var frontPackagesSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontPackagesSegmentsForDisplay_property.prop
    }
  }
  var frontPads_property = EBTransientProperty_MergerPadArray ()

  var frontPads_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.frontPads_property.prop
    }
  }
  var frontPadsForDisplay_property = EBTransientProperty_MergerPadArray ()

  var frontPadsForDisplay_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.frontPadsForDisplay_property.prop
    }
  }
  var frontTrackSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontTrackSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontTrackSegments_property.prop
    }
  }
  var frontTrackSegmentsForDisplay_property = EBTransientProperty_MergerSegmentArray ()

  var frontTrackSegmentsForDisplay_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontTrackSegmentsForDisplay_property.prop
    }
  }
  var holes_property = EBTransientProperty_MergerHoleArray ()

  var holes_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.holes_property.prop
    }
  }
  var holesForDisplay_property = EBTransientProperty_MergerHoleArray ()

  var holesForDisplay_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.holesForDisplay_property.prop
    }
  }
  var instanceCount_property = EBTransientProperty_Int ()

  var instanceCount_property_selection : EBSelection <Int> {
    get {
      return self.instanceCount_property.prop
    }
  }
  var modelHeight_property = EBPropertyProxy_Int ()

  var modelHeight_property_selection : EBSelection <Int> {
    get {
      return self.modelHeight_property.prop
    }
  }
  var modelHeightUnit_property = EBPropertyProxy_Int ()

  var modelHeightUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelHeightUnit_property.prop
    }
  }
  var modelWidth_property = EBPropertyProxy_Int ()

  var modelWidth_property_selection : EBSelection <Int> {
    get {
      return self.modelWidth_property.prop
    }
  }
  var modelWidthUnit_property = EBPropertyProxy_Int ()

  var modelWidthUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelWidthUnit_property.prop
    }
  }
  var name_property = EBPropertyProxy_String ()

  var name_property_selection : EBSelection <String> {
    get {
      return self.name_property.prop
    }
  }
  var padsHoles_property = EBTransientProperty_MergerHoleArray ()

  var padsHoles_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.padsHoles_property.prop
    }
  }
  var viaShapes_property = EBTransientProperty_MergerViaShapeArray ()

  var viaShapes_property_selection : EBSelection <MergerViaShapeArray> {
    get {
      return self.viaShapes_property.prop
    }
  }
  var viaShapesForDisplay_property = EBTransientProperty_MergerViaShapeArray ()

  var viaShapesForDisplay_property_selection : EBSelection <MergerViaShapeArray> {
    get {
      return self.viaShapesForDisplay_property.prop
    }
  }
  var viasHoles_property = EBTransientProperty_MergerHoleArray ()

  var viasHoles_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.viasHoles_property.prop
    }
  }
  var zoom_property = EBPropertyProxy_Int ()

  var zoom_property_selection : EBSelection <Int> {
    get {
      return self.zoom_property.prop
    }
  }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_BoardModelEntity, file:String, line:Int) {
    mModel = model
    bind_property_artworkName (model: model)
    bind_property_backComponentNameSegments (model: model)
    bind_property_backComponentNameSegmentsForDisplay (model: model)
    bind_property_backComponentValueSegments (model: model)
    bind_property_backComponentValuesForDisplay (model: model)
    bind_property_backLayoutTextsSegments (model: model)
    bind_property_backLayoutTextsSegmentsForDisplay (model: model)
    bind_property_backLegendTextsSegments (model: model)
    bind_property_backLegendTextsSegmentsForDisplay (model: model)
    bind_property_backPackagesSegments (model: model)
    bind_property_backPackagesSegmentsForDisplay (model: model)
    bind_property_backPads (model: model)
    bind_property_backPadsForDisplay (model: model)
    bind_property_backTrackSegments (model: model)
    bind_property_backTrackSegmentsForDisplay (model: model)
    bind_property_boardLimitWidth (model: model)
    bind_property_boardLimitWidthUnit (model: model)
    bind_property_boardLimits (model: model)
    bind_property_frontComponentNameSegments (model: model)
    bind_property_frontComponentNameSegmentsForDisplay (model: model)
    bind_property_frontComponentValueSegments (model: model)
    bind_property_frontComponentValuesForDisplay (model: model)
    bind_property_frontLayoutTextsSegments (model: model)
    bind_property_frontLayoutTextsSegmentsForDisplay (model: model)
    bind_property_frontLegendTextsSegments (model: model)
    bind_property_frontLegendTextsSegmentsForDisplay (model: model)
    bind_property_frontPackagesSegments (model: model)
    bind_property_frontPackagesSegmentsForDisplay (model: model)
    bind_property_frontPads (model: model)
    bind_property_frontPadsForDisplay (model: model)
    bind_property_frontTrackSegments (model: model)
    bind_property_frontTrackSegmentsForDisplay (model: model)
    bind_property_holes (model: model)
    bind_property_holesForDisplay (model: model)
    bind_property_instanceCount (model: model)
    bind_property_modelHeight (model: model)
    bind_property_modelHeightUnit (model: model)
    bind_property_modelWidth (model: model)
    bind_property_modelWidthUnit (model: model)
    bind_property_name (model: model)
    bind_property_padsHoles (model: model)
    bind_property_viaShapes (model: model)
    bind_property_viaShapesForDisplay (model: model)
    bind_property_viasHoles (model: model)
    bind_property_zoom (model: model)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize ())
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame:thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (mEasyBindingsObjectIndex) + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_PMMergerDocument_mBoardModelSelection.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
    mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame:r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "artworkName",
      idx:self.artworkName_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.artworkName_property.mObserverExplorer,
      valueExplorer:&self.artworkName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "boardLimitWidth",
      idx:self.boardLimitWidth_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.boardLimitWidth_property.mObserverExplorer,
      valueExplorer:&self.boardLimitWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "boardLimitWidthUnit",
      idx:self.boardLimitWidthUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.boardLimitWidthUnit_property.mObserverExplorer,
      valueExplorer:&self.boardLimitWidthUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelHeight",
      idx:self.modelHeight_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelHeight_property.mObserverExplorer,
      valueExplorer:&self.modelHeight_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelHeightUnit",
      idx:self.modelHeightUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelHeightUnit_property.mObserverExplorer,
      valueExplorer:&self.modelHeightUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelWidth",
      idx:self.modelWidth_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelWidth_property.mObserverExplorer,
      valueExplorer:&self.modelWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelWidthUnit",
      idx:self.modelWidthUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelWidthUnit_property.mObserverExplorer,
      valueExplorer:&self.modelWidthUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "name",
      idx:self.name_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.name_property.mObserverExplorer,
      valueExplorer:&self.name_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "zoom",
      idx:self.zoom_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.zoom_property.mObserverExplorer,
      valueExplorer:&self.zoom_property.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    view.frame = viewFrame
  //--- Set content size
    mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_PMMergerDocument_mBoardModelSelection.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (mEasyBindingsObjectIndex) + className
    mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    let sw = NSScrollView (frame:frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  func showObjectWindowFromExplorerButton (_ : Any) {
    if mExplorerWindow == nil {
      buildExplorerWindow ()
    }
    mExplorerWindow?.makeKeyAndOrderFront(nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  func deleteSelectionControllerWindowAction (_ : Any) {
    clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton!.target = nil
    mExplorerWindow?.orderOut (nil)
    mExplorerWindow = nil
  }

  //···················································································································*

  private final func bind_property_artworkName (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_artworkName (self.artworkName_property)
    self.artworkName_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.artworkName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.artworkName_property.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.artworkName_property.setProp (inValue)
          }
        }
      }
    }
    self.artworkName_property.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.artworkName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentNameSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backComponentNameSegments (self.backComponentNameSegments_property)
    self.backComponentNameSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentNameSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentNameSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backComponentNameSegmentsForDisplay (self.backComponentNameSegmentsForDisplay_property)
    self.backComponentNameSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentNameSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentValueSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backComponentValueSegments (self.backComponentValueSegments_property)
    self.backComponentValueSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentValueSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentValuesForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backComponentValuesForDisplay (self.backComponentValuesForDisplay_property)
    self.backComponentValuesForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentValuesForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLayoutTextsSegments (self.backLayoutTextsSegments_property)
    self.backLayoutTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLayoutTextsSegmentsForDisplay (self.backLayoutTextsSegmentsForDisplay_property)
    self.backLayoutTextsSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLegendTextsSegments (self.backLegendTextsSegments_property)
    self.backLegendTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLegendTextsSegmentsForDisplay (self.backLegendTextsSegmentsForDisplay_property)
    self.backLegendTextsSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPackagesSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backPackagesSegments (self.backPackagesSegments_property)
    self.backPackagesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPackagesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPackagesSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backPackagesSegmentsForDisplay (self.backPackagesSegmentsForDisplay_property)
    self.backPackagesSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPackagesSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPads (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backPads (self.backPads_property)
    self.backPads_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPads_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPadsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backPadsForDisplay (self.backPadsForDisplay_property)
    self.backPadsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPadsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backTrackSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backTrackSegments (self.backTrackSegments_property)
    self.backTrackSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backTrackSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backTrackSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backTrackSegmentsForDisplay (self.backTrackSegmentsForDisplay_property)
    self.backTrackSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backTrackSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimitWidth (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_boardLimitWidth (self.boardLimitWidth_property)
    self.boardLimitWidth_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimitWidth_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.boardLimitWidth_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.boardLimitWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.boardLimitWidth_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.boardLimitWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimitWidthUnit (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_boardLimitWidthUnit (self.boardLimitWidthUnit_property)
    self.boardLimitWidthUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimitWidthUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.boardLimitWidthUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.boardLimitWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.boardLimitWidthUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.boardLimitWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimits (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_boardLimits (self.boardLimits_property)
    self.boardLimits_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerBoardLimits> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimits_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentNameSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontComponentNameSegments (self.frontComponentNameSegments_property)
    self.frontComponentNameSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentNameSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentNameSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontComponentNameSegmentsForDisplay (self.frontComponentNameSegmentsForDisplay_property)
    self.frontComponentNameSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentNameSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentValueSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontComponentValueSegments (self.frontComponentValueSegments_property)
    self.frontComponentValueSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentValueSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentValuesForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontComponentValuesForDisplay (self.frontComponentValuesForDisplay_property)
    self.frontComponentValuesForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentValuesForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLayoutTextsSegments (self.frontLayoutTextsSegments_property)
    self.frontLayoutTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLayoutTextsSegmentsForDisplay (self.frontLayoutTextsSegmentsForDisplay_property)
    self.frontLayoutTextsSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLegendTextsSegments (self.frontLegendTextsSegments_property)
    self.frontLegendTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLegendTextsSegmentsForDisplay (self.frontLegendTextsSegmentsForDisplay_property)
    self.frontLegendTextsSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPackagesSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontPackagesSegments (self.frontPackagesSegments_property)
    self.frontPackagesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPackagesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPackagesSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontPackagesSegmentsForDisplay (self.frontPackagesSegmentsForDisplay_property)
    self.frontPackagesSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPackagesSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPads (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontPads (self.frontPads_property)
    self.frontPads_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPads_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPadsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontPadsForDisplay (self.frontPadsForDisplay_property)
    self.frontPadsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPadsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontTrackSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontTrackSegments (self.frontTrackSegments_property)
    self.frontTrackSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontTrackSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontTrackSegmentsForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontTrackSegmentsForDisplay (self.frontTrackSegmentsForDisplay_property)
    self.frontTrackSegmentsForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontTrackSegmentsForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_holes (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_holes (self.holes_property)
    self.holes_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.holes_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_holesForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_holesForDisplay (self.holesForDisplay_property)
    self.holesForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.holesForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_instanceCount (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_instanceCount (self.instanceCount_property)
    self.instanceCount_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.instanceCount_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelHeight (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelHeight (self.modelHeight_property)
    self.modelHeight_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelHeight_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelHeight_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelHeight_property.setProp (inValue)
          }
        }
      }
    }
    self.modelHeight_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelHeight_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelHeightUnit (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelHeightUnit (self.modelHeightUnit_property)
    self.modelHeightUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelHeightUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelHeightUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelHeightUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelHeightUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelHeightUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelWidth (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelWidth (self.modelWidth_property)
    self.modelWidth_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelWidth_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelWidth_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.modelWidth_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelWidthUnit (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelWidthUnit (self.modelWidthUnit_property)
    self.modelWidthUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelWidthUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelWidthUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelWidthUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_name (self.name_property)
    self.name_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.name_property.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.name_property.setProp (inValue)
          }
        }
      }
    }
    self.name_property.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.name_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padsHoles (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_padsHoles (self.padsHoles_property)
    self.padsHoles_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padsHoles_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viaShapes (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_viaShapes (self.viaShapes_property)
    self.viaShapes_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerViaShapeArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viaShapes_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viaShapesForDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_viaShapesForDisplay (self.viaShapesForDisplay_property)
    self.viaShapesForDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerViaShapeArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viaShapesForDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viasHoles (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_viasHoles (self.viasHoles_property)
    self.viasHoles_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viasHoles_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_zoom (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_zoom (self.zoom_property)
    self.zoom_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.zoom_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.zoom_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.zoom_property.setProp (inValue)
          }
        }
      }
    }
    self.zoom_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.zoom_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }



  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
  //--- artworkName
    self.artworkName_property.readModelFunction = nil 
    self.artworkName_property.writeModelFunction = nil 
    self.artworkName_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_artworkName (self.artworkName_property)
  //--- backComponentNameSegments
    self.backComponentNameSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentNameSegments (self.backComponentNameSegments_property)
  //--- backComponentNameSegmentsForDisplay
    self.backComponentNameSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentNameSegmentsForDisplay (self.backComponentNameSegmentsForDisplay_property)
  //--- backComponentValueSegments
    self.backComponentValueSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentValueSegments (self.backComponentValueSegments_property)
  //--- backComponentValuesForDisplay
    self.backComponentValuesForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentValuesForDisplay (self.backComponentValuesForDisplay_property)
  //--- backLayoutTextsSegments
    self.backLayoutTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsSegments (self.backLayoutTextsSegments_property)
  //--- backLayoutTextsSegmentsForDisplay
    self.backLayoutTextsSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsSegmentsForDisplay (self.backLayoutTextsSegmentsForDisplay_property)
  //--- backLegendTextsSegments
    self.backLegendTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsSegments (self.backLegendTextsSegments_property)
  //--- backLegendTextsSegmentsForDisplay
    self.backLegendTextsSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsSegmentsForDisplay (self.backLegendTextsSegmentsForDisplay_property)
  //--- backPackagesSegments
    self.backPackagesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPackagesSegments (self.backPackagesSegments_property)
  //--- backPackagesSegmentsForDisplay
    self.backPackagesSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPackagesSegmentsForDisplay (self.backPackagesSegmentsForDisplay_property)
  //--- backPads
    self.backPads_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPads (self.backPads_property)
  //--- backPadsForDisplay
    self.backPadsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPadsForDisplay (self.backPadsForDisplay_property)
  //--- backTrackSegments
    self.backTrackSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backTrackSegments (self.backTrackSegments_property)
  //--- backTrackSegmentsForDisplay
    self.backTrackSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backTrackSegmentsForDisplay (self.backTrackSegmentsForDisplay_property)
  //--- boardLimitWidth
    self.boardLimitWidth_property.readModelFunction = nil 
    self.boardLimitWidth_property.writeModelFunction = nil 
    self.boardLimitWidth_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimitWidth (self.boardLimitWidth_property)
  //--- boardLimitWidthUnit
    self.boardLimitWidthUnit_property.readModelFunction = nil 
    self.boardLimitWidthUnit_property.writeModelFunction = nil 
    self.boardLimitWidthUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimitWidthUnit (self.boardLimitWidthUnit_property)
  //--- boardLimits
    self.boardLimits_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimits (self.boardLimits_property)
  //--- frontComponentNameSegments
    self.frontComponentNameSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentNameSegments (self.frontComponentNameSegments_property)
  //--- frontComponentNameSegmentsForDisplay
    self.frontComponentNameSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentNameSegmentsForDisplay (self.frontComponentNameSegmentsForDisplay_property)
  //--- frontComponentValueSegments
    self.frontComponentValueSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentValueSegments (self.frontComponentValueSegments_property)
  //--- frontComponentValuesForDisplay
    self.frontComponentValuesForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentValuesForDisplay (self.frontComponentValuesForDisplay_property)
  //--- frontLayoutTextsSegments
    self.frontLayoutTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsSegments (self.frontLayoutTextsSegments_property)
  //--- frontLayoutTextsSegmentsForDisplay
    self.frontLayoutTextsSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsSegmentsForDisplay (self.frontLayoutTextsSegmentsForDisplay_property)
  //--- frontLegendTextsSegments
    self.frontLegendTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsSegments (self.frontLegendTextsSegments_property)
  //--- frontLegendTextsSegmentsForDisplay
    self.frontLegendTextsSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsSegmentsForDisplay (self.frontLegendTextsSegmentsForDisplay_property)
  //--- frontPackagesSegments
    self.frontPackagesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPackagesSegments (self.frontPackagesSegments_property)
  //--- frontPackagesSegmentsForDisplay
    self.frontPackagesSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPackagesSegmentsForDisplay (self.frontPackagesSegmentsForDisplay_property)
  //--- frontPads
    self.frontPads_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPads (self.frontPads_property)
  //--- frontPadsForDisplay
    self.frontPadsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPadsForDisplay (self.frontPadsForDisplay_property)
  //--- frontTrackSegments
    self.frontTrackSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontTrackSegments (self.frontTrackSegments_property)
  //--- frontTrackSegmentsForDisplay
    self.frontTrackSegmentsForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontTrackSegmentsForDisplay (self.frontTrackSegmentsForDisplay_property)
  //--- holes
    self.holes_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_holes (self.holes_property)
  //--- holesForDisplay
    self.holesForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_holesForDisplay (self.holesForDisplay_property)
  //--- instanceCount
    self.instanceCount_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_instanceCount (self.instanceCount_property)
  //--- modelHeight
    self.modelHeight_property.readModelFunction = nil 
    self.modelHeight_property.writeModelFunction = nil 
    self.modelHeight_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelHeight (self.modelHeight_property)
  //--- modelHeightUnit
    self.modelHeightUnit_property.readModelFunction = nil 
    self.modelHeightUnit_property.writeModelFunction = nil 
    self.modelHeightUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelHeightUnit (self.modelHeightUnit_property)
  //--- modelWidth
    self.modelWidth_property.readModelFunction = nil 
    self.modelWidth_property.writeModelFunction = nil 
    self.modelWidth_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelWidth (self.modelWidth_property)
  //--- modelWidthUnit
    self.modelWidthUnit_property.readModelFunction = nil 
    self.modelWidthUnit_property.writeModelFunction = nil 
    self.modelWidthUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelWidthUnit (self.modelWidthUnit_property)
  //--- name
    self.name_property.readModelFunction = nil 
    self.name_property.writeModelFunction = nil 
    self.name_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_name (self.name_property)
  //--- padsHoles
    self.padsHoles_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_padsHoles (self.padsHoles_property)
  //--- viaShapes
    self.viaShapes_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viaShapes (self.viaShapes_property)
  //--- viaShapesForDisplay
    self.viaShapesForDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viaShapesForDisplay (self.viaShapesForDisplay_property)
  //--- viasHoles
    self.viasHoles_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viasHoles (self.viasHoles_property)
  //--- zoom
    self.zoom_property.readModelFunction = nil 
    self.zoom_property.writeModelFunction = nil 
    self.zoom_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_zoom (self.zoom_property)
  //---
    mModel = nil    
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

