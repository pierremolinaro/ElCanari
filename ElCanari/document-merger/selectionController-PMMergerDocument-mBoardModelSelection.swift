//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    SelectionController_PMMergerDocument_mBoardModelSelection                                                        *
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@objc(SelectionController_PMMergerDocument_mBoardModelSelection)
final class SelectionController_PMMergerDocument_mBoardModelSelection : EBObject {
  private var mModel : ReadOnlyArrayOf_BoardModelEntity?

  //····················································································································
  //   SELECTION OBSERVABLE PROPERTIES
  //····················································································································

  var artworkName_property = EBPropertyProxy_String ()

  var artworkName_property_selection : EBSelection <String> {
    get {
      return self.artworkName_property.prop
    }
  }
  var backComponentNameSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentNameSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentNameSegments_property.prop
    }
  }
  var backComponentValueSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backComponentValueSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backComponentValueSegments_property.prop
    }
  }
  var backLayoutTextsLayer_property = EBTransientProperty_CALayer ()

  var backLayoutTextsLayer_property_selection : EBSelection <CALayer> {
    get {
      return self.backLayoutTextsLayer_property.prop
    }
  }
  var backLayoutTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var backLayoutTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backLayoutTextsLayerDisplay_property.prop
    }
  }
  var backLayoutTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLayoutTextsSegments_property.prop
    }
  }
  var backLegendTextsLayer_property = EBTransientProperty_CALayer ()

  var backLegendTextsLayer_property_selection : EBSelection <CALayer> {
    get {
      return self.backLegendTextsLayer_property.prop
    }
  }
  var backLegendTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var backLegendTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.backLegendTextsLayerDisplay_property.prop
    }
  }
  var backLegendTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backLegendTextsSegments_property.prop
    }
  }
  var backPackagesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backPackagesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backPackagesSegments_property.prop
    }
  }
  var backPads_property = EBTransientProperty_MergerPadArray ()

  var backPads_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.backPads_property.prop
    }
  }
  var backTrackSegments_property = EBTransientProperty_MergerSegmentArray ()

  var backTrackSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.backTrackSegments_property.prop
    }
  }
  var boardLimitWidth_property = EBPropertyProxy_Int ()

  var boardLimitWidth_property_selection : EBSelection <Int> {
    get {
      return self.boardLimitWidth_property.prop
    }
  }
  var boardLimitWidthUnit_property = EBPropertyProxy_Int ()

  var boardLimitWidthUnit_property_selection : EBSelection <Int> {
    get {
      return self.boardLimitWidthUnit_property.prop
    }
  }
  var boardLimits_property = EBTransientProperty_MergerBoardLimits ()

  var boardLimits_property_selection : EBSelection <MergerBoardLimits> {
    get {
      return self.boardLimits_property.prop
    }
  }
  var frontComponentNameSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentNameSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentNameSegments_property.prop
    }
  }
  var frontComponentValueSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontComponentValueSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontComponentValueSegments_property.prop
    }
  }
  var frontLayoutTextsLayer_property = EBTransientProperty_CALayer ()

  var frontLayoutTextsLayer_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLayoutTextsLayer_property.prop
    }
  }
  var frontLayoutTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var frontLayoutTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLayoutTextsLayerDisplay_property.prop
    }
  }
  var frontLayoutTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLayoutTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLayoutTextsSegments_property.prop
    }
  }
  var frontLegendTextsLayer_property = EBTransientProperty_CALayer ()

  var frontLegendTextsLayer_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLegendTextsLayer_property.prop
    }
  }
  var frontLegendTextsLayerDisplay_property = EBTransientProperty_CALayer ()

  var frontLegendTextsLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.frontLegendTextsLayerDisplay_property.prop
    }
  }
  var frontLegendTextsSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontLegendTextsSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontLegendTextsSegments_property.prop
    }
  }
  var frontPackagesSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontPackagesSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontPackagesSegments_property.prop
    }
  }
  var frontPads_property = EBTransientProperty_MergerPadArray ()

  var frontPads_property_selection : EBSelection <MergerPadArray> {
    get {
      return self.frontPads_property.prop
    }
  }
  var frontTrackSegments_property = EBTransientProperty_MergerSegmentArray ()

  var frontTrackSegments_property_selection : EBSelection <MergerSegmentArray> {
    get {
      return self.frontTrackSegments_property.prop
    }
  }
  var holes_property = EBTransientProperty_MergerHoleArray ()

  var holes_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.holes_property.prop
    }
  }
  var instanceCount_property = EBTransientProperty_Int ()

  var instanceCount_property_selection : EBSelection <Int> {
    get {
      return self.instanceCount_property.prop
    }
  }
  var modelHeight_property = EBPropertyProxy_Int ()

  var modelHeight_property_selection : EBSelection <Int> {
    get {
      return self.modelHeight_property.prop
    }
  }
  var modelHeightUnit_property = EBPropertyProxy_Int ()

  var modelHeightUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelHeightUnit_property.prop
    }
  }
  var modelLayerDisplay_property = EBTransientProperty_CALayer ()

  var modelLayerDisplay_property_selection : EBSelection <CALayer> {
    get {
      return self.modelLayerDisplay_property.prop
    }
  }
  var modelWidth_property = EBPropertyProxy_Int ()

  var modelWidth_property_selection : EBSelection <Int> {
    get {
      return self.modelWidth_property.prop
    }
  }
  var modelWidthUnit_property = EBPropertyProxy_Int ()

  var modelWidthUnit_property_selection : EBSelection <Int> {
    get {
      return self.modelWidthUnit_property.prop
    }
  }
  var name_property = EBPropertyProxy_String ()

  var name_property_selection : EBSelection <String> {
    get {
      return self.name_property.prop
    }
  }
  var padsHoles_property = EBTransientProperty_MergerHoleArray ()

  var padsHoles_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.padsHoles_property.prop
    }
  }
  var viaShapes_property = EBTransientProperty_MergerViaShapeArray ()

  var viaShapes_property_selection : EBSelection <MergerViaShapeArray> {
    get {
      return self.viaShapes_property.prop
    }
  }
  var viasHoles_property = EBTransientProperty_MergerHoleArray ()

  var viasHoles_property_selection : EBSelection <MergerHoleArray> {
    get {
      return self.viasHoles_property.prop
    }
  }
  var zoom_property = EBPropertyProxy_Int ()

  var zoom_property_selection : EBSelection <Int> {
    get {
      return self.zoom_property.prop
    }
  }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_BoardModelEntity, file:String, line:Int) {
    mModel = model
    bind_property_artworkName (model: model)
    bind_property_backComponentNameSegments (model: model)
    bind_property_backComponentValueSegments (model: model)
    bind_property_backLayoutTextsLayer (model: model)
    bind_property_backLayoutTextsLayerDisplay (model: model)
    bind_property_backLayoutTextsSegments (model: model)
    bind_property_backLegendTextsLayer (model: model)
    bind_property_backLegendTextsLayerDisplay (model: model)
    bind_property_backLegendTextsSegments (model: model)
    bind_property_backPackagesSegments (model: model)
    bind_property_backPads (model: model)
    bind_property_backTrackSegments (model: model)
    bind_property_boardLimitWidth (model: model)
    bind_property_boardLimitWidthUnit (model: model)
    bind_property_boardLimits (model: model)
    bind_property_frontComponentNameSegments (model: model)
    bind_property_frontComponentValueSegments (model: model)
    bind_property_frontLayoutTextsLayer (model: model)
    bind_property_frontLayoutTextsLayerDisplay (model: model)
    bind_property_frontLayoutTextsSegments (model: model)
    bind_property_frontLegendTextsLayer (model: model)
    bind_property_frontLegendTextsLayerDisplay (model: model)
    bind_property_frontLegendTextsSegments (model: model)
    bind_property_frontPackagesSegments (model: model)
    bind_property_frontPads (model: model)
    bind_property_frontTrackSegments (model: model)
    bind_property_holes (model: model)
    bind_property_instanceCount (model: model)
    bind_property_modelHeight (model: model)
    bind_property_modelHeightUnit (model: model)
    bind_property_modelLayerDisplay (model: model)
    bind_property_modelWidth (model: model)
    bind_property_modelWidthUnit (model: model)
    bind_property_name (model: model)
    bind_property_padsHoles (model: model)
    bind_property_viaShapes (model: model)
    bind_property_viasHoles (model: model)
    bind_property_zoom (model: model)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize ())
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame:thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (mEasyBindingsObjectIndex) + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_PMMergerDocument_mBoardModelSelection.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
    mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame:r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "artworkName",
      idx:self.artworkName_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.artworkName_property.mObserverExplorer,
      valueExplorer:&self.artworkName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "boardLimitWidth",
      idx:self.boardLimitWidth_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.boardLimitWidth_property.mObserverExplorer,
      valueExplorer:&self.boardLimitWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "boardLimitWidthUnit",
      idx:self.boardLimitWidthUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.boardLimitWidthUnit_property.mObserverExplorer,
      valueExplorer:&self.boardLimitWidthUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelHeight",
      idx:self.modelHeight_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelHeight_property.mObserverExplorer,
      valueExplorer:&self.modelHeight_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelHeightUnit",
      idx:self.modelHeightUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelHeightUnit_property.mObserverExplorer,
      valueExplorer:&self.modelHeightUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelWidth",
      idx:self.modelWidth_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelWidth_property.mObserverExplorer,
      valueExplorer:&self.modelWidth_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "modelWidthUnit",
      idx:self.modelWidthUnit_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.modelWidthUnit_property.mObserverExplorer,
      valueExplorer:&self.modelWidthUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "name",
      idx:self.name_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.name_property.mObserverExplorer,
      valueExplorer:&self.name_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "zoom",
      idx:self.zoom_property.mEasyBindingsObjectIndex,
      y:&y,
      view:view,
      observerExplorer:&self.zoom_property.mObserverExplorer,
      valueExplorer:&self.zoom_property.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    view.frame = viewFrame
  //--- Set content size
    mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_PMMergerDocument_mBoardModelSelection.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (mEasyBindingsObjectIndex) + className
    mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    let sw = NSScrollView (frame:frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  func showObjectWindowFromExplorerButton (_ : Any) {
    if mExplorerWindow == nil {
      buildExplorerWindow ()
    }
    mExplorerWindow?.makeKeyAndOrderFront(nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  func deleteSelectionControllerWindowAction (_ : Any) {
    clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton!.target = nil
    mExplorerWindow?.orderOut (nil)
    mExplorerWindow = nil
  }

  //···················································································································*

  private final func bind_property_artworkName (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_artworkName (self.artworkName_property)
    self.artworkName_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.artworkName_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.artworkName_property.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.artworkName_property.setProp (inValue)
          }
        }
      }
    }
    self.artworkName_property.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.artworkName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentNameSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backComponentNameSegments (self.backComponentNameSegments_property)
    self.backComponentNameSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentNameSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backComponentValueSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backComponentValueSegments (self.backComponentValueSegments_property)
    self.backComponentValueSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backComponentValueSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsLayer (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLayoutTextsLayer (self.backLayoutTextsLayer_property)
    self.backLayoutTextsLayer_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsLayer_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLayoutTextsLayerDisplay (self.backLayoutTextsLayerDisplay_property)
    self.backLayoutTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLayoutTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLayoutTextsSegments (self.backLayoutTextsSegments_property)
    self.backLayoutTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLayoutTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsLayer (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLegendTextsLayer (self.backLegendTextsLayer_property)
    self.backLegendTextsLayer_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsLayer_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLegendTextsLayerDisplay (self.backLegendTextsLayerDisplay_property)
    self.backLegendTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backLegendTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backLegendTextsSegments (self.backLegendTextsSegments_property)
    self.backLegendTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backLegendTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPackagesSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backPackagesSegments (self.backPackagesSegments_property)
    self.backPackagesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPackagesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backPads (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backPads (self.backPads_property)
    self.backPads_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backPads_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_backTrackSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_backTrackSegments (self.backTrackSegments_property)
    self.backTrackSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.backTrackSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimitWidth (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_boardLimitWidth (self.boardLimitWidth_property)
    self.boardLimitWidth_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimitWidth_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.boardLimitWidth_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.boardLimitWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.boardLimitWidth_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.boardLimitWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimitWidthUnit (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_boardLimitWidthUnit (self.boardLimitWidthUnit_property)
    self.boardLimitWidthUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimitWidthUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.boardLimitWidthUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.boardLimitWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.boardLimitWidthUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.boardLimitWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_boardLimits (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_boardLimits (self.boardLimits_property)
    self.boardLimits_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerBoardLimits> ()
          var isMultipleSelection = false
          for object in v {
            switch object.boardLimits_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentNameSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontComponentNameSegments (self.frontComponentNameSegments_property)
    self.frontComponentNameSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentNameSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontComponentValueSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontComponentValueSegments (self.frontComponentValueSegments_property)
    self.frontComponentValueSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontComponentValueSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsLayer (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLayoutTextsLayer (self.frontLayoutTextsLayer_property)
    self.frontLayoutTextsLayer_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsLayer_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLayoutTextsLayerDisplay (self.frontLayoutTextsLayerDisplay_property)
    self.frontLayoutTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLayoutTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLayoutTextsSegments (self.frontLayoutTextsSegments_property)
    self.frontLayoutTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLayoutTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsLayer (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLegendTextsLayer (self.frontLegendTextsLayer_property)
    self.frontLegendTextsLayer_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsLayer_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsLayerDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLegendTextsLayerDisplay (self.frontLegendTextsLayerDisplay_property)
    self.frontLegendTextsLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontLegendTextsSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontLegendTextsSegments (self.frontLegendTextsSegments_property)
    self.frontLegendTextsSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontLegendTextsSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPackagesSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontPackagesSegments (self.frontPackagesSegments_property)
    self.frontPackagesSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPackagesSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontPads (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontPads (self.frontPads_property)
    self.frontPads_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerPadArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontPads_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_frontTrackSegments (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_frontTrackSegments (self.frontTrackSegments_property)
    self.frontTrackSegments_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerSegmentArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.frontTrackSegments_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_holes (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_holes (self.holes_property)
    self.holes_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.holes_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_instanceCount (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_instanceCount (self.instanceCount_property)
    self.instanceCount_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.instanceCount_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelHeight (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelHeight (self.modelHeight_property)
    self.modelHeight_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelHeight_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelHeight_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelHeight_property.setProp (inValue)
          }
        }
      }
    }
    self.modelHeight_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelHeight_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelHeightUnit (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelHeightUnit (self.modelHeightUnit_property)
    self.modelHeightUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelHeightUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelHeightUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelHeightUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelHeightUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelHeightUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelLayerDisplay (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelLayerDisplay (self.modelLayerDisplay_property)
    self.modelLayerDisplay_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<CALayer> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelLayerDisplay_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelWidth (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelWidth (self.modelWidth_property)
    self.modelWidth_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelWidth_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelWidth_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.modelWidth_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_modelWidthUnit (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_modelWidthUnit (self.modelWidthUnit_property)
    self.modelWidthUnit_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.modelWidthUnit_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.modelWidthUnit_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.modelWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.modelWidthUnit_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.modelWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_name (self.name_property)
    self.name_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.name_property.writeModelFunction = { (inValue : String) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.name_property.setProp (inValue)
          }
        }
      }
    }
    self.name_property.validateAndWriteModelFunction = { (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.name_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padsHoles (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_padsHoles (self.padsHoles_property)
    self.padsHoles_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padsHoles_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viaShapes (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_viaShapes (self.viaShapes_property)
    self.viaShapes_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerViaShapeArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viaShapes_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_viasHoles (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_viasHoles (self.viasHoles_property)
    self.viasHoles_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<MergerHoleArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.viasHoles_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_zoom (model : ReadOnlyArrayOf_BoardModelEntity) {
    model.addEBObserverOf_zoom (self.zoom_property)
    self.zoom_property.readModelFunction = {
      if let model = self.mModel {
        switch model.prop {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set<Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.zoom_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.zoom_property.writeModelFunction = { (inValue : Int) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.zoom_property.setProp (inValue)
          }
        }
      }
    }
    self.zoom_property.validateAndWriteModelFunction = { (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self.mModel {
        switch model.prop {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.zoom_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }



  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
  //--- artworkName
    self.artworkName_property.readModelFunction = nil 
    self.artworkName_property.writeModelFunction = nil 
    self.artworkName_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_artworkName (self.artworkName_property)
  //--- backComponentNameSegments
    self.backComponentNameSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentNameSegments (self.backComponentNameSegments_property)
  //--- backComponentValueSegments
    self.backComponentValueSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backComponentValueSegments (self.backComponentValueSegments_property)
  //--- backLayoutTextsLayer
    self.backLayoutTextsLayer_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsLayer (self.backLayoutTextsLayer_property)
  //--- backLayoutTextsLayerDisplay
    self.backLayoutTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsLayerDisplay (self.backLayoutTextsLayerDisplay_property)
  //--- backLayoutTextsSegments
    self.backLayoutTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLayoutTextsSegments (self.backLayoutTextsSegments_property)
  //--- backLegendTextsLayer
    self.backLegendTextsLayer_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsLayer (self.backLegendTextsLayer_property)
  //--- backLegendTextsLayerDisplay
    self.backLegendTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsLayerDisplay (self.backLegendTextsLayerDisplay_property)
  //--- backLegendTextsSegments
    self.backLegendTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backLegendTextsSegments (self.backLegendTextsSegments_property)
  //--- backPackagesSegments
    self.backPackagesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPackagesSegments (self.backPackagesSegments_property)
  //--- backPads
    self.backPads_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backPads (self.backPads_property)
  //--- backTrackSegments
    self.backTrackSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_backTrackSegments (self.backTrackSegments_property)
  //--- boardLimitWidth
    self.boardLimitWidth_property.readModelFunction = nil 
    self.boardLimitWidth_property.writeModelFunction = nil 
    self.boardLimitWidth_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimitWidth (self.boardLimitWidth_property)
  //--- boardLimitWidthUnit
    self.boardLimitWidthUnit_property.readModelFunction = nil 
    self.boardLimitWidthUnit_property.writeModelFunction = nil 
    self.boardLimitWidthUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimitWidthUnit (self.boardLimitWidthUnit_property)
  //--- boardLimits
    self.boardLimits_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_boardLimits (self.boardLimits_property)
  //--- frontComponentNameSegments
    self.frontComponentNameSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentNameSegments (self.frontComponentNameSegments_property)
  //--- frontComponentValueSegments
    self.frontComponentValueSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontComponentValueSegments (self.frontComponentValueSegments_property)
  //--- frontLayoutTextsLayer
    self.frontLayoutTextsLayer_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsLayer (self.frontLayoutTextsLayer_property)
  //--- frontLayoutTextsLayerDisplay
    self.frontLayoutTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsLayerDisplay (self.frontLayoutTextsLayerDisplay_property)
  //--- frontLayoutTextsSegments
    self.frontLayoutTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLayoutTextsSegments (self.frontLayoutTextsSegments_property)
  //--- frontLegendTextsLayer
    self.frontLegendTextsLayer_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsLayer (self.frontLegendTextsLayer_property)
  //--- frontLegendTextsLayerDisplay
    self.frontLegendTextsLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsLayerDisplay (self.frontLegendTextsLayerDisplay_property)
  //--- frontLegendTextsSegments
    self.frontLegendTextsSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontLegendTextsSegments (self.frontLegendTextsSegments_property)
  //--- frontPackagesSegments
    self.frontPackagesSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPackagesSegments (self.frontPackagesSegments_property)
  //--- frontPads
    self.frontPads_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontPads (self.frontPads_property)
  //--- frontTrackSegments
    self.frontTrackSegments_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_frontTrackSegments (self.frontTrackSegments_property)
  //--- holes
    self.holes_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_holes (self.holes_property)
  //--- instanceCount
    self.instanceCount_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_instanceCount (self.instanceCount_property)
  //--- modelHeight
    self.modelHeight_property.readModelFunction = nil 
    self.modelHeight_property.writeModelFunction = nil 
    self.modelHeight_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelHeight (self.modelHeight_property)
  //--- modelHeightUnit
    self.modelHeightUnit_property.readModelFunction = nil 
    self.modelHeightUnit_property.writeModelFunction = nil 
    self.modelHeightUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelHeightUnit (self.modelHeightUnit_property)
  //--- modelLayerDisplay
    self.modelLayerDisplay_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelLayerDisplay (self.modelLayerDisplay_property)
  //--- modelWidth
    self.modelWidth_property.readModelFunction = nil 
    self.modelWidth_property.writeModelFunction = nil 
    self.modelWidth_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelWidth (self.modelWidth_property)
  //--- modelWidthUnit
    self.modelWidthUnit_property.readModelFunction = nil 
    self.modelWidthUnit_property.writeModelFunction = nil 
    self.modelWidthUnit_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_modelWidthUnit (self.modelWidthUnit_property)
  //--- name
    self.name_property.readModelFunction = nil 
    self.name_property.writeModelFunction = nil 
    self.name_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_name (self.name_property)
  //--- padsHoles
    self.padsHoles_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_padsHoles (self.padsHoles_property)
  //--- viaShapes
    self.viaShapes_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viaShapes (self.viaShapes_property)
  //--- viasHoles
    self.viasHoles_property.readModelFunction = nil 
    self.mModel?.removeEBObserverOf_viasHoles (self.viasHoles_property)
  //--- zoom
    self.zoom_property.readModelFunction = nil 
    self.zoom_property.writeModelFunction = nil 
    self.zoom_property.validateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_zoom (self.zoom_property)
  //---
    mModel = nil    
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

